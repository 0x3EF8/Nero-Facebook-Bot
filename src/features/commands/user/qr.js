/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                            QR CODE COMMAND                                    â•‘
 * â•‘              Generate QR codes from text or URLs                              â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * This command generates a QR code image from the provided text or URL.
 * If a name is provided, it creates a styled card with the name below.
 * Uses the QR Server API for generation.
 *
 * @author 0x3EF8
 * @version 1.1.0
 */

"use strict";

const axios = require("axios");
const fs = require("fs");
const path = require("path");
const { createCanvas, loadImage } = require("canvas");
const { getTempDirSync } = require("../../../utils/paths");

/**
 * Check if the input looks like a person's name
 * @param {string} text - Input text
 * @returns {boolean}
 */
function isName(text) {
    // Names typically:
    // - Don't contain URLs, emails, or code-like characters
    // - Are 1-5 words (allowing commas for "Last, First Middle" format)
    // - Don't start with numbers

    const urlPattern = /^(https?:\/\/|www\.|[a-zA-Z0-9.-]+\.[a-z]{2,})/i;
    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    // Allow commas, periods, hyphens (common in names like "Jr." or "Mary-Jane")
    const codeChars = /[!@#$%^&*()_+=[\]{};':"\\|<>/?0-9]/;

    if (urlPattern.test(text)) return false;
    if (emailPattern.test(text)) return false;
    if (codeChars.test(text)) return false;

    // Check if it looks like a name (1-5 words)
    // Remove commas and periods for word counting
    const cleanText = text.replace(/[,.]/g, " ").trim();
    const words = cleanText.split(/\s+/).filter((w) => w.length > 0);
    if (words.length < 1 || words.length > 6) return false;

    // Each word should be reasonable length for a name
    for (const word of words) {
        if (word.length < 1 || word.length > 25) return false;
    }

    return true;
}

/**
 * Create a professional styled QR card with name label (High Quality)
 * @param {Buffer} qrImageBuffer - QR code image buffer
 * @param {string} name - Name to display
 * @returns {Promise<Buffer>}
 */
async function createNameCard(qrImageBuffer, name) {
    const qrImage = await loadImage(qrImageBuffer);

    // High-Res Dimensions
    const padding = 130;
    const qrSize = 1000;
    const nameAreaHeight = 260;
    const footerHeight = 100;
    const cardWidth = qrSize + padding * 2;
    const cardHeight = padding + qrSize + nameAreaHeight + footerHeight;

    // Create canvas
    const canvas = createCanvas(cardWidth, cardHeight);
    const ctx = canvas.getContext("2d");

    // Smooth rendering
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high"; // Best quality

    // Rounded Corners Path
    const cornerRadius = 60;
    ctx.beginPath();
    ctx.moveTo(cornerRadius, 0);
    ctx.lineTo(cardWidth - cornerRadius, 0);
    ctx.quadraticCurveTo(cardWidth, 0, cardWidth, cornerRadius);
    ctx.lineTo(cardWidth, cardHeight - cornerRadius);
    ctx.quadraticCurveTo(cardWidth, cardHeight, cardWidth - cornerRadius, cardHeight);
    ctx.lineTo(cornerRadius, cardHeight);
    ctx.quadraticCurveTo(0, cardHeight, 0, cardHeight - cornerRadius);
    ctx.lineTo(0, cornerRadius);
    ctx.quadraticCurveTo(0, 0, cornerRadius, 0);
    ctx.closePath();

    // Clip and Fill Background
    ctx.save();
    ctx.clip();
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, cardWidth, cardHeight);
    ctx.restore();

    // Subtle Border
    ctx.strokeStyle = "#E0E0E0";
    ctx.lineWidth = 6;
    ctx.stroke();

    // Draw QR code centered
    const qrX = (cardWidth - qrSize) / 2;
    const qrY = padding;
    ctx.drawImage(qrImage, qrX, qrY, qrSize, qrSize);

    // Draw Name
    const displayName = name.trim().toUpperCase();
    ctx.fillStyle = "#333333";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Dynamic Font Sizing (High Res)
    let fontSize = 110;
    ctx.font = `bold ${fontSize}px Arial, sans-serif`;
    const maxTextWidth = cardWidth - padding * 1.5;

    while (ctx.measureText(displayName).width > maxTextWidth && fontSize > 40) {
        fontSize -= 5;
        ctx.font = `bold ${fontSize}px Arial, sans-serif`;
    }

    const nameY = qrY + qrSize + 150;
    ctx.fillText(displayName, cardWidth / 2, nameY);

    // Draw Footer/Watermark
    ctx.fillStyle = "#AAAAAA";
    ctx.font = "30px Arial, sans-serif";
    ctx.textAlign = "right";
    ctx.fillText("Generated by Nero", cardWidth - 40, cardHeight - 40);

    return canvas.toBuffer("image/png");
}

module.exports = {
    config: {
        name: "qr",
        aliases: ["qrcode", "qrgen"],
        description: "Generate a QR code from text or URL",
        usage: "qr <text, URL, or name>",
        category: "user",
        cooldown: 5,
        permissions: "user",
        enabled: true,
        dmOnly: false,
        groupOnly: false,
    },

    /**
     * Command execution function
     * @param {Object} context - Command context
     */
    async execute({ api, event, args, config }) {
        const threadID = event.threadID;
        const messageID = event.messageID;

        // Check if data was provided (args is still useful for quick empty check)
        if (!args.length) {
            const actualPrefix = config.bot.prefixEnabled ? config.bot.prefix : "";
            const commandName = this.config.name;
            return api.sendMessage(
                "âš ï¸ Please provide text, URL, or name to generate QR code.\n\n" +
                "Usage:\n" +
                `â€¢ ${actualPrefix}${commandName} <text> [-c <color>] - Generate styled QR with optional color\n` +
                `â€¢ ${actualPrefix}${commandName} <list> - Bulk generate (numbered list or newlines)\n\n` +
                "Options:\n" +
                "â€¢ -c, -color : Hex code (e.g. #FF0000) or name (e.g. orange)\n\n" +
                "Examples:\n" +
                `â€¢ ${actualPrefix}${commandName} https://google.com -c red\n` +
                `â€¢ ${actualPrefix}${commandName} -c orange\n` +
                `1. Garcia, Adrian Michael\n` +
                `2. Santos, Bianca Rose`,
                threadID,
                messageID
            );
        }

        let body = event.body || "";

        // Remove the command trigger (first word)
        // This handles !qr, /qr, qr, etc.
        body = body.replace(/^[^\s]+\s*/, "");

        // Default color
        let color = "000000";

        // Extract color flag using regex (case insensitive)
        // Matches -c or -color followed by a hex or word
        const colorRegex = /(?:-c|-color)\s+([#a-zA-Z0-9]+)/i;
        const colorMatch = body.match(colorRegex);

        if (colorMatch) {
            let colorVal = colorMatch[1];

            // Remove the flag and value from body
            body = body.replace(colorMatch[0], "");

            // Process color value
            colorVal = colorVal.replace("#", "");

            // Map common names to hex
            const colorMap = {
                red: "FF0000",
                green: "008000",
                blue: "0000FF",
                yellow: "FFFF00",
                purple: "800080",
                orange: "FFA500",
                black: "000000",
                white: "FFFFFF",
                pink: "FFC0CB",
                cyan: "00FFFF",
            };

            if (colorMap[colorVal.toLowerCase()]) {
                color = colorMap[colorVal.toLowerCase()];
            } else if (/^[0-9A-Fa-f]{6}$/.test(colorVal)) {
                color = colorVal;
            }
        }

        // Clean up the body text
        const rawData = body.trim();

        if (!rawData) {
            return api.sendMessage(
                "âš ï¸ Please provide text or data for the QR code.",
                threadID,
                messageID
            );
        }

        // Split by newline or numbering pattern (e.g. "1. Item 2. Item")
        // This handles both newlines and single-line lists
        const items = rawData
            .split(/(?:\r?\n)|(?=\b\d+\.\s+)/)
            .map((item) => item.replace(/^[\d]+[.)-]\s* /, "").trim()) // Remove "1. " prefix
            .filter((item) => item.length > 0)
            .slice(0, 30); // Limit to 30

        if (items.length === 0) return;

        api.setMessageReaction("â³", messageID, () => { }, true);

        const tempDir = getTempDirSync();

        const tempFiles = [];
        const streams = [];

        try {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const encodedData = encodeURIComponent(item);
                const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=1000x1000&data=${encodedData}&color=${color}`;

                // Download the QR code image
                const response = await axios({
                    method: "GET",
                    url: qrUrl,
                    responseType: "arraybuffer",
                });

                let finalImage;

                // Check if input is a name - create styled card
                if (isName(item)) {
                    try {
                        finalImage = await createNameCard(response.data, item);
                    } catch (_cardError) {
                        finalImage = response.data;
                    }
                } else {
                    finalImage = response.data;
                }

                const tempFile = path.join(tempDir, `qr_${Date.now()}_${i}.png`);
                fs.writeFileSync(tempFile, finalImage);
                tempFiles.push(tempFile);
                streams.push(fs.createReadStream(tempFile));
            }

            const messageBody =
                items.length > 1
                    ? `ğŸ“± Generated ${items.length} QR Codes`
                    : isName(items[0])
                        ? `ğŸ“± QR Name Card Generated`
                        : `ğŸ“± QR Code Generated\n\nğŸ“ Data: ${items[0].length > 50 ? items[0].substring(0, 50) + "..." : items[0]}`;

            // Send all QR codes in one message
            await api.sendMessage(
                {
                    body: messageBody,
                    attachment: streams,
                },
                threadID,
                messageID
            );

            // Success reaction
            api.setMessageReaction("âœ…", messageID, () => { }, true);
        } catch (error) {
            api.setMessageReaction("âŒ", messageID, () => { }, true);
            return api.sendMessage(
                `âŒ Failed to generate QR codes: ${error.message}`,
                threadID,
                null,
                messageID
            );
        } finally {
            // Cleanup temp files
            // Wait a bit to ensure streams are closed/sent
            setTimeout(() => {
                tempFiles.forEach((file) => {
                    if (fs.existsSync(file)) {
                        try {
                            fs.unlinkSync(file);
                        } catch (_e) {
                            api.sendMessage("âŒ Failed to generate QR code", threadID, null, messageID);
                        }
                    }
                });
            }, 5000);
        }
    },
};
