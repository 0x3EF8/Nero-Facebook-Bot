/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                          BETA AI EVENT HANDLER                                â•‘
 * â•‘              Neural Core Engine v3.0 - SUPER AI EDITION                       â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @description Context-aware AI chatbot powered by Google Gemini 2.5-Flash
 * @author 0x3EF8
 * @version 3.0.0-SUPER-AI
 * @license MIT
 * 
 * ğŸ§  SUPER AI FEATURES:
 * - Intelligent Query Optimization: AI analyzes and optimizes search queries
 * - Smart Content Scoring: ML-powered ranking of video/music results
 * - Contextual Understanding: Analyzes lyrics mood, themes, and emotions
 * - Predictive Alternatives: AI generates smart fallback search queries
 * - Error Diagnosis: AI diagnoses errors and suggests recovery strategies
 * - Dynamic Commentary: Real-time AI insights about content
 * - Quality Assessment: Intelligent evaluation of content relevance
 * 
 * ğŸ’¬ CHAT AI FEATURES:
 * - Context Memory: Remembers last 10 messages per thread
 * - Image Analysis: Supports up to 20 images per reply
 * - Bilingual: Auto-detects and responds in English or Bisaya
 * - Human Behavior: Natural reading, thinking, and typing delays
 * - Smart Reactions: Loading (â³) and completion (âœ…/âŒ) indicators
 * - Full Responses: Sends complete messages at once
 * - Reply Tracking: Detects when users reply to Beta's messages
 * 
 * ğŸµ MUSIC AI FEATURES:
 * - AI Query Analysis: Optimizes search terms with confidence scoring
 * - Content Curator: Scores and ranks results based on quality/relevance
 * - Lyrics Intelligence: Analyzes mood, themes, and emotions in lyrics
 * - Smart Alternatives: Generates creative fallback queries automatically
 * - Contextual Captions: AI-generated captions based on song analysis
 * - Direct Downloads: Minimal messages, maximum efficiency
 * 
 * ğŸ¬ VIDEO AI FEATURES:
 * - Intelligent Search: AI-optimized video discovery
 * - Content Type Detection: Identifies music videos, tutorials, entertainment
 * - Quality Scoring: Ranks videos by relevance and official status
 * - Smart Recovery: Auto-generates alternative searches on failure
 * - Contextual Commentary: AI insights about video content
 * 
 * âš¡ ACTIVATION METHODS:
 * - @Beta mention in message
 * - Reply to Beta's previous message
 * 
 * ğŸ¯ AI CAPABILITIES:
 * - Homework/test assistance with AI-powered explanations
 * - Math problem solving with detailed steps
 * - Image text recognition and intelligent response
 * - Multi-image comparison and analysis
 * - Natural conversation with context awareness
 * - Intelligent error recovery and suggestions
 * - Real-time content analysis and optimization
 * 
 * ğŸ“Š EVENT TYPES HANDLED:
 * - message        (Regular messages with AI processing)
 * - message_reply  (Replies with AI-enhanced context)
 */

const axios = require("axios");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const { Innertube, Utils, Platform } = require("youtubei.js");
const cheerio = require("cheerio");
const fs = require("fs");
const path = require("path");
const config = require("../../config/config");
const chalk = require("chalk");

/**
 * Event configuration
 */
module.exports.config = {
    name: "betaAI",
    description: "Multilingual AI chatbot powered by Google Gemini - understands and responds in any language",
    eventTypes: ["message", "message_reply"],
    priority: 100,
    enabled: true,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                              MEMORY MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const chatMemory = new Map();    // threadID -> [{ name, message }]
const nameCache = new Map();     // senderID -> displayName
const betaMessageIDs = new Set(); // Track Beta's messages for reply detection

const MAX_HISTORY = 10;           // Messages to remember per thread
const MAX_TRACKED_MESSAGES = 50;  // Maximum Beta messages to track
const MAX_IMAGES_PER_REPLY = 20;  // Maximum images to analyze

// YouTube configuration
let GENIUS_ACCESS_TOKEN = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                       GEMINI API KEY ROTATION SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const rateLimitedKeys = new Map(); // key -> timestamp when rate limited

/**
 * Get the next available API key (rotates on rate limit)
 * @returns {string|null} Available API key or null if all exhausted
 */
function getAvailableApiKey() {
  const primaryKey = config.apiKeys?.gemini;
  const backupKeys = config.apiKeys?.geminiBackups || [];
  const allKeys = [primaryKey, ...backupKeys].filter(Boolean);
  
  if (allKeys.length === 0) return null;
  
  // Clean up expired rate limits (reset after 60 seconds)
  const now = Date.now();
  for (const [key, timestamp] of rateLimitedKeys.entries()) {
    if (now - timestamp > 60000) {
      rateLimitedKeys.delete(key);
    }
  }
  
  // Find first non-rate-limited key
  for (let i = 0; i < allKeys.length; i++) {
    const key = allKeys[i];
    if (!rateLimitedKeys.has(key)) {
      return key;
    }
  }
  
  // All keys rate limited - return the one that was limited longest ago
  let oldestKey = allKeys[0];
  let oldestTime = Infinity;
  for (const [key, timestamp] of rateLimitedKeys.entries()) {
    if (timestamp < oldestTime && allKeys.includes(key)) {
      oldestTime = timestamp;
      oldestKey = key;
    }
  }
  return oldestKey;
}

/**
 * Mark an API key as rate limited
 * @param {string} apiKey - The key that hit rate limit
 */
function markKeyRateLimited(apiKey) {
  rateLimitedKeys.set(apiKey, Date.now());
  console.log(chalk.yellow(`âš  API key ${apiKey.substring(0, 10)}... rate limited, rotating to backup`));
}

/**
 * Generate content with automatic API key rotation on rate limit
 * @param {string} prompt - The prompt or array of prompts/images
 * @param {Array} imageParts - Optional image parts
 * @param {number} maxRetries - Maximum retry attempts
 * @returns {Promise<Object>} Generation result
 */
async function generateWithFallback(prompt, imageParts = [], maxRetries = 3) {
  let lastError = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const apiKey = getAvailableApiKey();
    
    if (!apiKey) {
      throw new Error("No Gemini API keys available");
    }
    
    try {
      const genAI = new GoogleGenerativeAI(apiKey);
      const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
      
      let result;
      if (imageParts.length > 0) {
        result = await model.generateContent([prompt, ...imageParts]);
      } else {
        result = await model.generateContent(prompt);
      }
      
      return result;
      
    } catch (error) {
      lastError = error;
      const errorMsg = error.message || String(error);
      
      // Check if it's a rate limit error (429)
      if (errorMsg.includes("429") || errorMsg.includes("quota") || errorMsg.includes("rate") || errorMsg.includes("Too Many Requests")) {
        markKeyRateLimited(apiKey);
        console.log(chalk.cyan(`ğŸ”„ Retrying with backup key (attempt ${attempt + 2}/${maxRetries})...`));
        
        // Small delay before retry
        await new Promise(resolve => { setTimeout(resolve, 1000); });
        continue;
      }
      
      // For other errors, don't retry
      throw error;
    }
  }
  
  throw lastError || new Error("All API key attempts failed");
}

// Setup JavaScript evaluator for YouTube URL deciphering
Platform.shim.eval = (data, env) => {
  const properties = [];

  if (env.n) {
    properties.push(`n: exportedVars.nFunction("${env.n}")`);
  }

  if (env.sig) {
    properties.push(`sig: exportedVars.sigFunction("${env.sig}")`);
  }

  const code = `${data.output}\nreturn { ${properties.join(", ")} }`;

  return new Function(code)();
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                         HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Robust user name resolver with multiple fallback strategies
 * Tries event data, cache, getUserInfo API, and thread participants
 * 
 * @param {Object} api - Facebook API instance
 * @param {string} senderID - User's Facebook ID
 * @param {Object} event - Message event object (may contain name)
 * @returns {Promise<string>} User's display name
 */
async function getUserName(api, senderID, event) {
  // Strategy 1: Check event object for immediate name
  if (event && (event.senderName || event.sender_fullname || event.name)) {
    const name = event.senderName || event.sender_fullname || event.name;
    nameCache.set(senderID, name);
    return name;
  }

  // Strategy 2: Check cache for previously resolved name
  if (nameCache.has(senderID)) {
    return nameCache.get(senderID);
  }

  // Strategy 3: Query API for user information
  try {
    if (typeof api.getUserInfo === "function") {
      let info = null;
      
      // Try both array and single ID formats
      try {
        info = await api.getUserInfo([senderID]);
      } catch {
        info = await api.getUserInfo(senderID);
      }

      // Parse various response formats
      let name = null;
      
      if (!info) {
        name = null;
      } else if (Array.isArray(info) && info.length > 0) {
        // Array format: find matching user
        const entry = info.find(e => e.id === senderID || e.userID === senderID) || info[0];
        name = entry && (entry.name || entry.fullName || entry.username || entry.displayName || entry.userName);
      } else if (typeof info === "object") {
        // Object format: check if keyed by senderID
        if (info[senderID]) {
          const entry = info[senderID];
          name = entry && (entry.name || entry.fullName || entry.displayName || entry.username);
        } else {
          name = info.name || info.fullName || info.displayName || info.username;
        }
      }

      if (name) {
        nameCache.set(senderID, name);
        return name;
      }
    }
  } catch (err) {
    console.warn(chalk.yellow("âš  getUserInfo failed:"), err.message || err);
  }

  // Strategy 4: Try thread participant list
  try {
    if (typeof api.getThreadInfo === "function" && event && event.threadID) {
      const tinfo = await api.getThreadInfo(event.threadID);
      
      // Check participants array
      if (tinfo && Array.isArray(tinfo.participants)) {
        const p = tinfo.participants.find(
          (p) => String(p.id || p.userID) === String(senderID) || 
                 String(p.fbId) === String(senderID)
        );
        
        if (p) {
          const name = p.name || p.fullName || p.displayName;
          if (name) {
            nameCache.set(senderID, name);
            return name;
          }
        }
      }
      
      // Check userInfo object
      if (tinfo && typeof tinfo.userInfo === "object") {
        const entry = tinfo.userInfo[senderID] || 
                      Object.values(tinfo.userInfo).find((x) => x.id === senderID);
        
        if (entry) {
          const name = entry.name || entry.fullName || entry.displayName;
          if (name) {
            nameCache.set(senderID, name);
            return name;
          }
        }
      }
      
      // Check userInfo object
      if (tinfo && typeof tinfo.userInfo === "object") {
        const entry = tinfo.userInfo[senderID] || 
                      Object.values(tinfo.userInfo).find((x) => x.id === senderID);
        
        if (entry) {
          const name = entry.name || entry.fullName || entry.displayName;
          if (name) {
            nameCache.set(senderID, name);
            return name;
          }
        }
      }
    }
  } catch {
    // Silent fail - this is a fallback strategy
  }

  // Strategy 5: Use senderID as last resort
  const fallback = String(senderID);
  nameCache.set(senderID, fallback);
  return fallback;
}

/**
 * Get all members in the group chat with their names
 * 
 * @param {Object} api - Facebook API instance
 * @param {string} threadID - Thread identifier
 * @returns {Promise<Map>} Map of userID -> userName
 */
async function getAllGroupMembers(api, threadID) {
  const members = new Map();
  
  try {
    if (typeof api.getThreadInfo === "function") {
      const threadInfo = await api.getThreadInfo(threadID);
      
      // userInfo is an ARRAY of user objects
      if (threadInfo && Array.isArray(threadInfo.userInfo)) {
        for (const user of threadInfo.userInfo) {
          const userID = String(user.id || user.userID);
          const userName = user.name || user.fullName || user.firstName || userID;
          
          // Validate userID is a real Facebook ID
          if (userID && userID !== 'undefined' && userID.length > 5 && /^\d+$/.test(userID)) {
            members.set(userID, userName);
            nameCache.set(userID, userName);
          }
        }
      }
      
      // Fallback: Check if userInfo is an object (different API versions)
      if (threadInfo && typeof threadInfo.userInfo === "object" && !Array.isArray(threadInfo.userInfo)) {
        for (const [uid, info] of Object.entries(threadInfo.userInfo)) {
          const userName = info.name || info.fullName || info.displayName || uid;
          
          // Validate uid is a real Facebook ID
          if (uid && uid.length > 5 && /^\d+$/.test(uid)) {
            members.set(uid, userName);
            nameCache.set(uid, userName);
          }
        }
      }
      
      // Also check deprecated participants array format
      if (threadInfo && Array.isArray(threadInfo.participants)) {
        for (const participant of threadInfo.participants) {
          const userID = String(participant.id || participant.userID || participant.fbId);
          const userName = participant.name || participant.fullName || participant.displayName || userID;
          
          // Validate userID
          if (userID && userID !== 'undefined' && userID.length > 5 && /^\d+$/.test(userID)) {
            // Only add if not already in map
            if (!members.has(userID)) {
              members.set(userID, userName);
              nameCache.set(userID, userName);
            }
          }
        }
      }
    }
  } catch (err) {
    console.warn(chalk.yellow("âš  Failed to get all group members:"), err.message || err);
  }
  
  return members;
}

/**
 * Change nickname for a user in the group
 * 
 * @param {Object} api - Facebook API instance
 * @param {string} threadID - Thread identifier
 * @param {string} targetID - Target user ID
 * @param {string} nickname - New nickname
 * @returns {Promise<boolean>} Success status
 */
async function changeNickname(api, threadID, targetID, nickname) {
  try {
    console.log(chalk.cyan(`   â””â”€ Calling api.nickname("${nickname}", "${threadID}", "${targetID}")`));
    
    const result = await api.nickname(nickname, threadID, targetID);
    
    console.log(chalk.green(`   â””â”€ API result:`, result));
    
    // Check if result indicates error
    if (result === false || (result && result.error)) {
      throw new Error(result.error || 'API returned false');
    }
    
    return true;
  } catch (err) {
    console.error(chalk.red("âŒ Failed to change nickname:"), err.message || err);
    return false;
  }
}

/**
 * Generate random pairs from group members
 * @param {Map} allMembers - Map of userID -> userName
 * @param {string} senderID - ID of user requesting pairs (optional)
 * @param {boolean} includeSender - Whether to include sender in random pairing
 * @returns {Array<{person1: {id, name}, person2: {id, name}}>}
 */
function generateRandomPairs(allMembers, senderID = null, includeSender = true) {
  const membersArray = Array.from(allMembers.entries())
    .map(([id, name]) => ({ id, name }));
  
  // If pairing sender with someone
  if (senderID && !includeSender) {
    const sender = membersArray.find(m => m.id === senderID);
    const others = membersArray.filter(m => m.id !== senderID);
    
    if (sender && others.length > 0) {
      const randomIndex = Math.floor(Math.random() * others.length);
      return [{ person1: sender, person2: others[randomIndex] }];
    }
    
    return [];
  }
  
  // Random pairing of all members
  const shuffled = [...membersArray].sort(() => Math.random() - 0.5);
  const pairs = [];
  
  for (let i = 0; i < shuffled.length - 1; i += 2) {
    pairs.push({
      person1: shuffled[i],
      person2: shuffled[i + 1]
    });
  }
  
  // If odd number, last person is solo
  if (shuffled.length % 2 !== 0) {
    pairs.push({
      person1: shuffled[shuffled.length - 1],
      person2: null // Solo
    });
  }
  
  return pairs;
}

/**
 * Download and convert image to base64 for Gemini API
 * Handles both static and animated images
 * 
 * @param {string} imageUrl - URL of the image
 * @param {string} type - Attachment type (photo or animated_image)
 * @returns {Promise<Object|null>} Image data object or null on error
 */
async function downloadImageAsBase64(imageUrl, type) {
  try {
    const response = await axios({
      url: imageUrl,
      method: "GET",
      responseType: "arraybuffer",
      timeout: 10000, // 10 second timeout
    });
    
    const base64Image = Buffer.from(response.data, "binary").toString("base64");
    const mimeType = type === "animated_image" ? "image/gif" : "image/jpeg";
    
    return {
      inlineData: {
        data: base64Image,
        mimeType: mimeType,
      },
    };
  } catch (err) {
    console.error(chalk.red("âŒ Image download error:"), err.message || err);
    return null;
  }
}

/**
 * Update chat memory with new message
 * Maintains rolling window of last N messages
 * 
 * @param {string} threadID - Thread identifier
 * @param {string} name - Sender's display name
 * @param {string} message - Message text
 */
function updateChatMemory(threadID, name, message) {
  if (!chatMemory.has(threadID)) {
    chatMemory.set(threadID, []);
  }
  
  const history = chatMemory.get(threadID);
  history.push({ name, message });
  
  // Keep only last N messages
  if (history.length > MAX_HISTORY) {
    history.shift();
  }
}

/**
 * Track Beta's message ID for reply detection
 * Maintains FIFO cache to prevent memory leaks
 * 
 * @param {string} messageID - Beta's message ID
 */
function trackBetaMessage(messageID) {
  betaMessageIDs.add(messageID);
  
  // Limit cache size
  if (betaMessageIDs.size > MAX_TRACKED_MESSAGES) {
    const firstID = betaMessageIDs.values().next().value;
    betaMessageIDs.delete(firstID);
  }
}

/**
 * Get Genius API access token using client credentials
 * @returns {Promise<string>} - The access token
 */
async function getGeniusAccessToken() {
  if (GENIUS_ACCESS_TOKEN) {
    return GENIUS_ACCESS_TOKEN;
  }

  try {
    const tokenUrl = 'https://api.genius.com/oauth/token';
    const response = await axios.post(tokenUrl, {
      client_id: config.geniusClientId,
      client_secret: config.geniusClientSecret,
      grant_type: 'client_credentials'
    });

    GENIUS_ACCESS_TOKEN = response.data.access_token;
    return GENIUS_ACCESS_TOKEN;
  } catch (error) {
    console.error("Error getting Genius access token:", error.message);
    GENIUS_ACCESS_TOKEN = config.geniusClientId;
    return GENIUS_ACCESS_TOKEN;
  }
}

/**
 * Search for lyrics using Genius API and web scraping
 * @param {string} songTitle - The song title to search for
 * @param {string} artist - The artist name
 * @returns {Promise<string|null>} - The lyrics or null if not found
 */
async function fetchLyrics(songTitle, artist) {
  try {
    const accessToken = await getGeniusAccessToken();

    const cleanTitle = songTitle
      .replace(/\(.*?official.*?\)/gi, '')
      .replace(/\[.*?official.*?\]/gi, '')
      .replace(/official music video/gi, '')
      .replace(/official video/gi, '')
      .replace(/lyrics video/gi, '')
      .replace(/lyric video/gi, '')
      .trim();

    const searchQuery = `${cleanTitle} ${artist}`;
    const searchUrl = `https://api.genius.com/search?q=${encodeURIComponent(searchQuery)}`;
    const searchResponse = await axios.get(searchUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      timeout: 10000,
    });

    if (!searchResponse.data.response.hits.length) {
      return null;
    }

    let bestMatch = null;
    for (const hit of searchResponse.data.response.hits) {
      const result = hit.result;
      if (
        result.url.includes('-script-') ||
        result.url.includes('-annotated') ||
        result.title.toLowerCase().includes('script') ||
        result.title.toLowerCase().includes('tracklist')
      ) {
        continue;
      }
      const artistMatch = result.primary_artist.name.toLowerCase().includes(artist.toLowerCase()) ||
                         artist.toLowerCase().includes(result.primary_artist.name.toLowerCase());
      
      if (artistMatch) {
        bestMatch = result;
        break;
      }
    }

    if (!bestMatch) {
      bestMatch = searchResponse.data.response.hits[0].result;
    }

    const songUrl = bestMatch.url;
    const pageResponse = await axios.get(songUrl, {
      timeout: 10000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    const $ = cheerio.load(pageResponse.data);

    let lyrics = "";
    const selectors = [
      '[class*="Lyrics__Container"]',
      '[data-lyrics-container="true"]',
      '.lyrics',
      '[class*="lyrics"]'
    ];

    for (const selector of selectors) {
      $(selector).each((i, elem) => {
        const html = $(elem).html();
        if (html) {
          const textWithBreaks = html
            .replace(/<br\s*\/?>/gi, '\n')
            .replace(/<\/div>/gi, '\n')
            .replace(/<div[^>]*>/gi, '');
          
          const decoded = $('<div>').html(textWithBreaks).text();
          lyrics += decoded.trim() + "\n\n";
        }
      });
      if (lyrics) break;
    }

    if (!lyrics) {
      return null;
    }

    lyrics = lyrics.trim();
    
    // Remove all metadata/junk from Genius
    lyrics = lyrics.replace(/^\d+\s+Contributors?.*?Lyrics/gis, '');
    lyrics = lyrics.replace(/^.*?Read More\s*/is, '');
    lyrics = lyrics.replace(/\d+\s*Contributors?/gi, '');
    lyrics = lyrics.replace(/Translations?/gi, '');
    lyrics = lyrics.replace(/Italiano|Afrikaans|FranÃ§ais|srpski|TÃ¼rkÃ§e|EspaÃ±ol|PortuguÃªs|Polski|Magyar|Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°|Tiáº¿ng Viá»‡t|ÄŒesky|Deutsch|SlovenÅ¡Äina|í•œêµ­ì–´|æ—¥æœ¬èª|ä¸­æ–‡|Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©|×¢×‘×¨×™×ª|à¹„à¸—à¸¢|Indonesia|Nederlands|Ğ ÑƒÑÑĞºĞ¸Ğ¹|Î•Î»Î»Î·Î½Î¹ÎºÎ¬|RomÃ¢nÄƒ|Svenska|Norsk|Dansk|Suomi|ÄŒeÅ¡tina/gi, '');
    lyrics = lyrics.replace(/^You might also like.*$/gim, '');
    lyrics = lyrics.replace(/See.*Live.*Get tickets as low as \$\d+/gi, '');
    lyrics = lyrics.replace(/Embed$/gim, '');
    lyrics = lyrics.replace(/\[.*?\]\s*$/gm, function(match) {
      // Keep section markers like [Verse], [Chorus], etc.
      if (/\[(Verse|Chorus|Intro|Bridge|Pre-Chorus|Outro|Refrain|Hook|Interlude)/i.test(match)) {
        return match;
      }
      return '';
    });
    
    const lines = lyrics.split('\n');
    let startIndex = 0;
    
    // Find where actual lyrics start
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (
        line.match(/^\[(?:Verse|Chorus|Intro|Bridge|Pre-Chorus|Outro|Refrain|Hook|Interlude)/i) ||
        (line.length > 0 && 
         !line.includes('Read More') && 
         !line.includes('Lyrics') && 
         !line.includes('Contributors') &&
         !line.includes('Translations') &&
         !/^(Italiano|Afrikaans|FranÃ§ais|srpski|TÃ¼rkÃ§e|EspaÃ±ol|PortuguÃªs)$/i.test(line) &&
         i < 15)
      ) {
        startIndex = i;
        break;
      }
    }
    
    // Clean up and filter empty lines
    lyrics = lines.slice(startIndex)
      .map(line => line.trim())
      .filter(line => {
        // Remove lines that are just language names or metadata
        if (/^(Italiano|Afrikaans|FranÃ§ais|srpski|TÃ¼rkÃ§e|EspaÃ±ol|PortuguÃªs|Polski|Magyar|Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°|Tiáº¿ng Viá»‡t|ÄŒesky|Deutsch|SlovenÅ¡Äina|í•œêµ­ì–´|æ—¥æœ¬èª|ä¸­æ–‡)$/i.test(line)) return false;
        if (/^\d+\s*Contributors?$/i.test(line)) return false;
        if (/^Translations?$/i.test(line)) return false;
        if (/^Embed$/i.test(line)) return false;
        if (/^You might also like$/i.test(line)) return false;
        return true;
      })
      .join('\n')
      .trim();
    
    // Remove multiple consecutive empty lines
    lyrics = lyrics.replace(/\n{3,}/g, '\n\n');
    
    return lyrics;
  } catch (error) {
    console.error("Error fetching lyrics:", error.message);
    return null;
  }
}

/**
 * Download music from YouTube with lyrics
 * @param {Object} api - Facebook API instance
 * @param {string} threadID - Thread identifier
 * @param {string} messageID - Message ID for reactions
 * @param {string} query - Search query
 * @param {Object} model - Gemini AI model for generating messages
 * @param {boolean} wantsLyrics - Whether user wants lyrics (default: false)
 * @returns {Promise<void>}
 */
async function downloadMusic(api, threadID, messageID, query, _model, wantsLyrics = false) {
  // Create model proxy with API key rotation (ignore passed model, use fallback system)
  const model = {
    generateContent: async (promptOrParts) => {
      if (Array.isArray(promptOrParts)) {
        const [prompt, ...images] = promptOrParts;
        return generateWithFallback(prompt, images);
      }
      return generateWithFallback(promptOrParts);
    }
  };

  const downloadDir = path.join(process.cwd(), "data", "temp");
  
  if (!fs.existsSync(downloadDir)) {
    fs.mkdirSync(downloadDir, { recursive: true });
  }

  let audioPath = null;

  try {
    api.setMessageReaction("â³", messageID, () => {}, true);

    const youtube = await Innertube.create({
      generate_session_locally: true,
    });

    const search = await youtube.search(query);
    let allVideos = search.results
      .filter((item) => item.type === "Video")
      .slice(0, 20); // Get more results to check

    if (allVideos.length === 0) {
      api.setMessageReaction("âŒ", messageID, () => {}, true);
      
      let notFoundText = "âŒ No music found for your search query.";
      try {
        const notFoundPrompt = `No music found for search query "${query}". Generate a short message (1 sentence) saying you couldn't find it. Be apologetic and friendly. Use emojis.`;
        const notFoundResult = await model.generateContent(notFoundPrompt);
        notFoundText = notFoundResult?.response && typeof notFoundResult.response.text === "function"
          ? await notFoundResult.response.text()
          : notFoundText;
      } catch {
        console.warn(chalk.yellow("âš  Failed to generate not found message"));
      }
      
      return api.sendMessage(notFoundText.trim(), threadID, messageID);
    }

    // AI-POWERED CONTENT SCORING
    console.log(chalk.magenta(` â”œâ”€ğŸ§  AI scoring ${allVideos.length} results for quality and relevance..."`));
    
    try {
      const videoTitles = allVideos.slice(0, 10).map((v, i) => 
        `${i + 1}. "${v.title.text}" by ${v.author?.name || 'Unknown'} (${v.duration?.text || 'N/A'})`
      ).join('\n');
      
      const scoringPrompt = `You are an expert music curator. Score these music search results for the query "${query}":

${videoTitles}

Return JSON array with scores 0-100 for each result based on:
- Title relevance to query
- Official vs unofficial (official = higher)
- Audio quality indicators ("official audio", "HQ", etc.)
- Avoid live versions, covers, remixes unless user asked for them
- Channel credibility

Format: [{"index": 1, "score": 95, "reason": "Official audio from verified artist"}, ...]
Return ONLY valid JSON array, no markdown.`;
      
      const scoringResult = await model.generateContent(scoringPrompt);
      const scoringText = scoringResult?.response && typeof scoringResult.response.text === "function"
        ? await scoringResult.response.text()
        : null;
      
      if (scoringText) {
        const cleanJson = scoringText.replace(/```json\n?|```\n?/g, '').trim();
        const scores = JSON.parse(cleanJson);
        
        // Sort by score and reorder allVideos
        scores.sort((a, b) => b.score - a.score);
        const reordered = scores.map(s => allVideos[s.index - 1]).filter(v => v);
        allVideos = reordered.concat(allVideos.filter(v => !reordered.includes(v)));
        
        console.log(chalk.green(` â”œâ”€âœ“ AI ranked results: #1 scored ${scores[0].score}% - ${scores[0].reason}`));
      }
    } catch (err) {
      console.warn(chalk.yellow("âš  AI scoring failed, using default order:"), err.message);
    }

    // Try to find a video within duration limit
    let selectedVideo = null;
    let videoTitle = "";
    let channelName = "";
    let duration = "";
    let foundWithinLimit = false;

    // First, check if any of the first results are within limit
    for (const video of allVideos) {
      try {
        const info = await youtube.getInfo(video.id);
        if (info.basic_info.duration <= 600 && info.basic_info.duration > 30) {
          selectedVideo = video;
          videoTitle = selectedVideo.title.text;
          channelName = selectedVideo.author?.name || "Unknown";
          duration = selectedVideo.duration?.text || "N/A";
          foundWithinLimit = true;
          console.log(chalk.green(` â”œâ”€âœ“ Found suitable music: ${videoTitle} (${Math.floor(info.basic_info.duration / 60)}:${String(Math.floor(info.basic_info.duration % 60)).padStart(2, '0')})`));
          break;
        }
      } catch {
        continue;
      }
    }

    // If no suitable video found in initial results, try AI-generated alternative searches
    if (!foundWithinLimit) {
      console.log(chalk.yellow(` â”œâ”€âš  No suitable music in first results, generating AI alternatives...`));
      
      let alternativeQueries = [
        `${query} official audio`,
        `${query} audio`,
        `${query} short version`
      ];
      
      // AI-GENERATED SMART ALTERNATIVES
      try {
        const altPrompt = `Generate 5 creative alternative search queries for: "${query}"

Consider:
- Adding "official audio", "radio edit", "clean version"
- Removing words like "music video", "official video"
- Trying artist name only if it's a song
- Adding "lyrics" or "audio" suffixes
- Fixing potential typos or alternate spellings

Return as JSON array of strings: ["query1", "query2", ...]
Return ONLY valid JSON array, no markdown.`;
        
        const altResult = await model.generateContent(altPrompt);
        const altText = altResult?.response && typeof altResult.response.text === "function"
          ? await altResult.response.text()
          : null;
        
        if (altText) {
          const cleanJson = altText.replace(/```json\n?|```\n?/g, '').trim();
          const aiAlternatives = JSON.parse(cleanJson);
          alternativeQueries = [...aiAlternatives, ...alternativeQueries];
          console.log(chalk.cyan(` â”œâ”€ğŸ§  AI generated ${aiAlternatives.length} smart alternatives`));
        }
      } catch {
        console.warn(chalk.yellow("âš  AI alternative generation failed, using defaults"));
      }
      
      for (const altQuery of alternativeQueries) {
        try {
          const altSearch = await youtube.search(altQuery);
          const altVideos = altSearch.results
            .filter((item) => item.type === "Video")
            .slice(0, 10);
          
          for (const video of altVideos) {
            const info = await youtube.getInfo(video.id);
            if (info.basic_info.duration <= 600 && info.basic_info.duration > 30) {
              selectedVideo = video;
              videoTitle = selectedVideo.title.text;
              channelName = selectedVideo.author?.name || "Unknown";
              duration = selectedVideo.duration?.text || "N/A";
              foundWithinLimit = true;
              console.log(chalk.green(` â”œâ”€âœ“ Found alternative: ${videoTitle} (${Math.floor(info.basic_info.duration / 60)}:${String(Math.floor(info.basic_info.duration % 60)).padStart(2, '0')})`));
              break;
            }
          }
          
          if (foundWithinLimit) break;
        } catch (err) {
          console.warn(chalk.yellow(`âš  Error in alternative search: ${err.message}`));
          continue;
        }
      }
    }

    // If still no suitable video, use the first result anyway but with a note
    if (!selectedVideo) {
      selectedVideo = allVideos[0];
      videoTitle = selectedVideo.title.text;
      channelName = selectedVideo.author?.name || "Unknown";
      duration = selectedVideo.duration?.text || "N/A";
      console.log(chalk.yellow(` â”œâ”€âš  Using first result despite duration`));
    }

    console.log(chalk.cyan(` â”œâ”€ğŸµ Found music: ${videoTitle} (${duration})`));
    api.setMessageReaction("â¬‡ï¸", messageID, () => {}, true);

    const info = await youtube.getInfo(selectedVideo.id);

    // Check duration one more time and truncate if necessary
    if (info.basic_info.duration > 600) {
      console.log(chalk.yellow(` â”œâ”€âš  Selected music is ${Math.floor(info.basic_info.duration / 60)} min, but will attempt download...`));
    }

    const sanitizedTitle = videoTitle
      .replace(/[/\\?%*:|"<>]/g, "-")
      .slice(0, 100);
    audioPath = path.join(downloadDir, `${Date.now()}-${sanitizedTitle}.mp3`);

    let downloadSuccess = false;
    let lastError = null;
    
    const qualityOptions = [
      { type: "audio", quality: "best" },
      { type: "audio", quality: "bestefficiency" },
      { type: "video+audio", quality: "bestefficiency", format: "mp4" },
    ];

    for (const options of qualityOptions) {
      try {
        const stream = await youtube.download(selectedVideo.id, options);
        const fileStream = fs.createWriteStream(audioPath);

        for await (const chunk of Utils.streamToIterable(stream)) {
          fileStream.write(chunk);
        }

        fileStream.end();

        await new Promise((resolve) => {
          fileStream.on("finish", resolve);
        });

        downloadSuccess = true;
        break;
      } catch (err) {
        lastError = err;
        if (fs.existsSync(audioPath)) {
          try {
            fs.unlinkSync(audioPath);
          } catch {
            // Ignore cleanup errors
          }
        }
        continue;
      }
    }

    if (!downloadSuccess) {
      throw lastError || new Error("Download failed with all quality options");
    }

    const stats = fs.statSync(audioPath);
    const fileSizeMB = stats.size / (1024 * 1024);

    if (fileSizeMB > 50) {
      fs.unlinkSync(audioPath);
      api.setMessageReaction("âŒ", messageID, () => {}, true);
      
      let tooLargeText = `âš ï¸ Audio file is too large (${fileSizeMB.toFixed(2)} MB)\n\nğŸ“ Maximum file size: 50 MB`;
      try {
        const tooLargePrompt = `The audio file is too large: ${fileSizeMB.toFixed(2)} MB, but maximum is 50 MB. Generate a short message (1-2 sentences) explaining this. Be apologetic but friendly. Use emojis.`;
        const tooLargeResult = await model.generateContent(tooLargePrompt);
        tooLargeText = tooLargeResult?.response && typeof tooLargeResult.response.text === "function"
          ? await tooLargeResult.response.text()
          : tooLargeText;
      } catch {
        console.warn(chalk.yellow("âš  Failed to generate too large message"));
      }
      
      return api.sendMessage(tooLargeText.trim(), threadID, messageID);
    }

    // Only fetch lyrics if user explicitly asked for them
    let lyrics = null;
    if (wantsLyrics) {
      console.log(chalk.cyan(` â”œâ”€ğŸ“ Fetching lyrics...`));
      lyrics = await fetchLyrics(videoTitle, channelName);
    }
    
    console.log(chalk.cyan(` â”œâ”€ğŸ”ƒ Uploading music...`));
    api.setMessageReaction("ğŸ”ƒ", messageID, () => {}, true);

    // AI-POWERED LYRICS ANALYSIS
    let lyricsContext = null;
    if (lyrics && wantsLyrics) {
      try {
        const lyricsAnalysisPrompt = `Analyze these lyrics briefly:

"${videoTitle}" by ${channelName}

${lyrics.substring(0, 500)}...

Return JSON with:
- "theme": main theme/emotion (1-2 words)
- "mood": overall mood (happy/sad/energetic/calm/etc)
- "funFact": one interesting observation about the lyrics

Return ONLY valid JSON, no markdown.`;
        
        const analysisResult = await model.generateContent(lyricsAnalysisPrompt);
        const analysisText = analysisResult?.response && typeof analysisResult.response.text === "function"
          ? await analysisResult.response.text()
          : null;
        
        if (analysisText) {
          const cleanJson = analysisText.replace(/```json\n?|```\n?/g, '').trim();
          lyricsContext = JSON.parse(cleanJson);
          console.log(chalk.magenta(` â”œâ”€ğŸ§  AI analyzed lyrics: Theme="${lyricsContext.theme}", Mood="${lyricsContext.mood}"`));
        }
      } catch {
        console.warn(chalk.yellow("âš  AI lyrics analysis failed"));
      }
      
      // Send lyrics with simple header - just the lyrics, no extra fluff
      await api.sendMessage(
        `ğŸ“ **${videoTitle}**\nğŸ‘¤ ${channelName}\n\n${lyrics}`,
        threadID
      );
    }

    // Send music with simple caption
    await api.sendMessage(
      {
        body: `ğŸµ ${videoTitle}\nğŸ‘¤ ${channelName}`,
        attachment: fs.createReadStream(audioPath),
      },
      threadID
    );

    console.log(chalk.green(` â”œâ”€âœ“ Music sent: ${videoTitle.substring(0, 40)}... (${fileSizeMB.toFixed(2)} MB)`));

    api.setMessageReaction("âœ…", messageID, () => {}, true);

    setTimeout(() => {
      try {
        if (fs.existsSync(audioPath)) {
          fs.unlinkSync(audioPath);
        }
      } catch (_err) {
        console.error(chalk.yellow("âš ï¸ Error cleaning up audio file:"), _err.message);
      }
    }, 5000);
  } catch (error) {
    console.error(chalk.red(` â”œâ”€âœ— Music download error: ${error.message}`));

    api.setMessageReaction("âŒ", messageID, () => {}, true);

    if (audioPath && fs.existsSync(audioPath)) {
      try {
        fs.unlinkSync(audioPath);
      } catch {
        // Ignore cleanup errors
      }
    }

    // AI-POWERED ERROR DIAGNOSIS & RECOVERY
    let errorMessage = "âŒ Error downloading music. Try a different search query.";
    
    try {
      const errorAnalysisPrompt = `An error occurred while downloading music for query "${query}". Error: ${error.message}

Diagnose the issue and suggest what the user should try:
- Network/connection issues?
- Video unavailable/restricted?
- Invalid search query?
- Technical limitation?

Return JSON:
{
  "diagnosis": "brief explanation of what went wrong",
  "suggestion": "friendly suggestion for what to try next",
  "alternativeQuery": "a better search query if the original was problematic"
}

Return ONLY valid JSON, no markdown.`;
      
      const errorResult = await model.generateContent(errorAnalysisPrompt);
      const errorText = errorResult?.response && typeof errorResult.response.text === "function"
        ? await errorResult.response.text()
        : null;
      
      if (errorText) {
        const cleanJson = errorText.replace(/```json\n?|```\n?/g, '').trim();
        const errorAnalysis = JSON.parse(cleanJson);
        
        console.log(chalk.magenta(` â”œâ”€ğŸ§  AI diagnosed error: ${errorAnalysis.diagnosis}`));
        console.log(chalk.cyan(` â”œâ”€ğŸ’¡ AI suggests: ${errorAnalysis.suggestion}`));
        
        errorMessage = `âŒ ${errorAnalysis.diagnosis}\n\nğŸ’¡ ${errorAnalysis.suggestion}`;
        
        if (errorAnalysis.alternativeQuery && errorAnalysis.alternativeQuery !== query) {
          errorMessage += `\n\nğŸ”„ Try: "${errorAnalysis.alternativeQuery}"`;
        }
      }
    } catch {
      console.warn(chalk.yellow("âš  AI error diagnosis failed"));
    }
    
    if (error.message?.includes("413") || error.message?.includes("Payload Too Large")) {
      errorMessage = "âŒ Audio file is too large for Messenger. Try searching for shorter songs.";
    } else if (error.message?.includes("403") || error.message?.includes("Forbidden")) {
      errorMessage = "âŒ Audio download blocked by YouTube. Try a different song.";
    } else if (error.message?.includes("404") || error.message?.includes("Not Found")) {
      errorMessage = "âŒ Music not found. The video may have been deleted.";
    }

    // Generate AI error message
    try {
      const errorPrompt = `Error downloading music. ${errorMessage}. Generate a short, apologetic message (1-2 sentences) about the error. Be friendly and suggest trying again. Use emojis.`;
      const errorResult = await model.generateContent(errorPrompt);
      errorMessage = errorResult?.response && typeof errorResult.response.text === "function"
        ? await errorResult.response.text()
        : errorMessage;
    } catch {
      console.warn(chalk.yellow("âš  Failed to generate error message"));
    }

    return api.sendMessage(errorMessage.trim(), threadID, messageID);
  }
}

/**
 * Get weather information for a location
 * @param {Object} api - Facebook API instance
 * @param {string} threadID - Thread identifier
 * @param {string} messageID - Message ID for reactions
 * @param {string} location - Location name
 * @returns {Promise<void>}
 */
async function getWeather(api, threadID, messageID, location) {
  try {
    api.setMessageReaction("ğŸ”", messageID, () => {}, true);

    const searchMsg = await api.sendMessage(
      `ğŸ” Searching weather for: "${location}"...`,
      threadID
    );

    // Get coordinates from location name using geocoding
    const geocodeUrl = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(location)}&count=1&language=en&format=json`;
    const geocodeResponse = await axios.get(geocodeUrl, { timeout: 10000 });

    if (!geocodeResponse.data.results || geocodeResponse.data.results.length === 0) {
      api.setMessageReaction("âŒ", messageID, () => {}, true);
      return api.sendMessage(
        `âŒ Location "${location}" not found. Please try a different location name.`,
        threadID,
        messageID
      );
    }

    const place = geocodeResponse.data.results[0];
    const placeName = `${place.name}${place.admin1 ? ', ' + place.admin1 : ''}${place.country ? ', ' + place.country : ''}`;

    await api.editMessage(
      `âœ… Found: ${placeName}\n\nâ¬‡ï¸ Getting weather data...`,
      searchMsg.messageID
    );

    api.setMessageReaction("ğŸŒ¤ï¸", messageID, () => {}, true);

    // Get comprehensive weather data
    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${place.latitude}&longitude=${place.longitude}&current=temperature_2m,relativehumidity_2m,apparent_temperature,is_day,precipitation,rain,showers,snowfall,weathercode,cloudcover,pressure_msl,surface_pressure,windspeed_10m,winddirection_10m,windgusts_10m&daily=weathercode,temperature_2m_max,temperature_2m_min,sunrise,sunset,uv_index_max,precipitation_sum,precipitation_hours,precipitation_probability_max,windspeed_10m_max,windgusts_10m_max,winddirection_10m_dominant&hourly=temperature_2m,relativehumidity_2m,precipitation_probability,precipitation,rain,showers,snowfall,weathercode,cloudcover,visibility,windspeed_10m,winddirection_10m&timezone=Asia/Manila&forecast_days=3`;
    const weatherResponse = await axios.get(weatherUrl, { timeout: 15000 });

    const current = weatherResponse.data.current;
    const daily = weatherResponse.data.daily;
    const hourly = weatherResponse.data.hourly;

    // Get current Manila time
    const now = new Date();
    const manilaTime = now.toLocaleString('en-US', { 
      timeZone: 'Asia/Manila', 
      dateStyle: 'full', 
      timeStyle: 'short' 
    });

    // Weather code descriptions with emojis
    const weatherCodes = {
      0: "â˜€ï¸ Clear sky",
      1: "ğŸŒ¤ï¸ Mainly clear",
      2: "â›… Partly cloudy",
      3: "â˜ï¸ Overcast",
      45: "ğŸŒ«ï¸ Foggy",
      48: "ğŸŒ«ï¸ Depositing rime fog",
      51: "ğŸŒ¦ï¸ Light drizzle",
      53: "ğŸŒ¦ï¸ Moderate drizzle",
      55: "ğŸŒ¦ï¸ Dense drizzle",
      61: "ğŸŒ§ï¸ Slight rain",
      63: "ğŸŒ§ï¸ Moderate rain",
      65: "ğŸŒ§ï¸ Heavy rain",
      71: "ğŸŒ¨ï¸ Slight snow",
      73: "ğŸŒ¨ï¸ Moderate snow",
      75: "ğŸŒ¨ï¸ Heavy snow",
      80: "ğŸŒ¦ï¸ Slight rain showers",
      81: "ğŸŒ§ï¸ Moderate rain showers",
      82: "ğŸŒ§ï¸ Violent rain showers",
      95: "â›ˆï¸ Thunderstorm",
      96: "â›ˆï¸ Thunderstorm with slight hail",
      99: "â›ˆï¸ Thunderstorm with heavy hail"
    };

    const weatherDescription = weatherCodes[current.weathercode] || "ğŸŒ¡ï¸ Unknown";
    const dayNight = current.is_day ? "â˜€ï¸ Day" : "ğŸŒ™ Night";

    // Wind direction helper
    const getWindDirection = (degrees) => {
      const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      const index = Math.round(degrees / 22.5) % 16;
      return directions[index];
    };

    // Sun times
    const todaySunrise = new Date(daily.sunrise[0]).toLocaleTimeString('en-US', { 
      timeZone: 'Asia/Manila', 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    const todaySunset = new Date(daily.sunset[0]).toLocaleTimeString('en-US', { 
      timeZone: 'Asia/Manila', 
      hour: '2-digit', 
      minute: '2-digit' 
    });

    // Next 24 hours forecast (every 3 hours)
    const currentHour = now.getHours();
    const forecast24h = [];
    for (let i = 0; i < 24; i += 3) {
      const hourIndex = currentHour + i;
      if (hourIndex < hourly.time.length) {
        const time = new Date(hourly.time[hourIndex]).toLocaleTimeString('en-US', {
          timeZone: 'Asia/Manila',
          hour: '2-digit',
          minute: '2-digit'
        });
        forecast24h.push(`${time}: ${hourly.temperature_2m[hourIndex]}Â°C ${weatherCodes[hourly.weathercode[hourIndex]] || 'ğŸŒ¡ï¸'}`);
      }
    }

    // 3-day forecast
    const forecast3day = [];
    for (let i = 0; i < Math.min(3, daily.time.length); i++) {
      const date = new Date(daily.time[i]).toLocaleDateString('en-US', {
        timeZone: 'Asia/Manila',
        weekday: 'short',
        month: 'short',
        day: 'numeric'
      });
      forecast3day.push(`${date}: ${daily.temperature_2m_max[i]}Â°C/${daily.temperature_2m_min[i]}Â°C ${weatherCodes[daily.weathercode[i]] || 'ğŸŒ¡ï¸'}`);
    }

    const weatherMessage = `ğŸŒ Weather Report for ${placeName}

ğŸ“… ${manilaTime}
${dayNight} â€¢ ${weatherDescription}

ğŸŒ¡ï¸ TEMPERATURE
  â€¢ Current: ${current.temperature_2m}Â°C
  â€¢ Feels Like: ${current.apparent_temperature}Â°C
  â€¢ High: ${daily.temperature_2m_max[0]}Â°C | Low: ${daily.temperature_2m_min[0]}Â°C

ğŸ’§ HUMIDITY & PRECIPITATION
  â€¢ Humidity: ${current.relativehumidity_2m}%
  â€¢ Precipitation: ${current.precipitation}mm
  â€¢ Rain: ${current.rain}mm | Showers: ${current.showers}mm
  â€¢ Snow: ${current.snowfall}mm
  â€¢ Chance Today: ${daily.precipitation_probability_max[0] || 0}%

ğŸ’¨ WIND
  â€¢ Speed: ${current.windspeed_10m} km/h
  â€¢ Direction: ${getWindDirection(current.winddirection_10m)} (${current.winddirection_10m}Â°)
  â€¢ Gusts: ${current.windgusts_10m} km/h
  â€¢ Max Today: ${daily.windspeed_10m_max[0]} km/h

ğŸŒ«ï¸ ATMOSPHERE
  â€¢ Cloud Cover: ${current.cloudcover}%
  â€¢ Pressure (MSL): ${current.pressure_msl} hPa
  â€¢ Surface Pressure: ${current.surface_pressure} hPa

ğŸŒ… SUN & UV
  â€¢ Sunrise: ${todaySunrise} | Sunset: ${todaySunset}
  â€¢ Max UV Index: ${daily.uv_index_max[0]}

ğŸ“Š 24-HOUR FORECAST
${forecast24h.join('\n')}

ğŸ“† 3-DAY FORECAST
${forecast3day.join('\n')}

Data: Open-Meteo API â€¢ Time: Asia/Manila`;

    await api.sendMessage(weatherMessage, threadID);

    console.log(chalk.green(` â”œâ”€âœ“ Weather sent for: ${placeName}`));

    api.setMessageReaction("âœ…", messageID, () => {}, true);

  } catch (error) {
    console.error(chalk.red(` â”œâ”€âœ— Weather error: ${error.message}`));

    api.setMessageReaction("âŒ", messageID, () => {}, true);

    let errorMessage = "âŒ Error getting weather data. Please try again.";
    
    if (error.message?.includes("timeout")) {
      errorMessage = "âŒ Weather service timeout. Please try again later.";
    } else if (error.message?.includes("404")) {
      errorMessage = "âŒ Location not found. Please check the location name.";
    }

    return api.sendMessage(errorMessage, threadID, messageID);
  }
}

/**
 * Download video from YouTube
 * @param {Object} api - Facebook API instance
 * @param {string} threadID - Thread identifier
 * @param {string} messageID - Message ID for reactions
 * @param {string} query - Search query
 * @param {Object} _model - Gemini AI model (unused, uses fallback system)
 * @returns {Promise<void>}
 */
async function downloadVideo(api, threadID, messageID, query, _model) {
  // Create model proxy with API key rotation (ignore passed model, use fallback system)
  const model = {
    generateContent: async (promptOrParts) => {
      if (Array.isArray(promptOrParts)) {
        const [prompt, ...images] = promptOrParts;
        return generateWithFallback(prompt, images);
      }
      return generateWithFallback(promptOrParts);
    }
  };

  const downloadDir = path.join(process.cwd(), "data", "temp");
  
  if (!fs.existsSync(downloadDir)) {
    fs.mkdirSync(downloadDir, { recursive: true });
  }

  let videoPath = null;

  try {
    api.setMessageReaction("â³", messageID, () => {}, true);

    // AI-POWERED SEARCH OPTIMIZATION FOR VIDEO
    console.log(chalk.magenta(` â”œâ”€ğŸ§  AI analyzing your video request..."`));
    let optimizedQuery = query;
    let searchStrategy = null;
    
    try {
      const analysisPrompt = `Analyze this video search query and provide optimization:

User Query: "${query}"

Provide a JSON response with:
1. "optimizedQuery": The best search terms (remove unnecessary words, fix typos, add keywords if needed)
2. "isAmbiguous": true if query is vague or might have multiple interpretations
3. "suggestedAlternatives": array of 3 alternative search terms if the main query might not work
4. "contentType": "music video", "movie", "tutorial", "vlog", or "entertainment"
5. "confidence": 0-100 score of how clear the request is

Return ONLY valid JSON, no markdown.`;
      
      const analysisResult = await model.generateContent(analysisPrompt);
      const analysisText = analysisResult?.response && typeof analysisResult.response.text === "function"
        ? await analysisResult.response.text()
        : null;
      
      if (analysisText) {
        const cleanJson = analysisText.replace(/```json\n?|```\n?/g, '').trim();
        searchStrategy = JSON.parse(cleanJson);
        
        if (searchStrategy.optimizedQuery && searchStrategy.confidence > 50) {
          optimizedQuery = searchStrategy.optimizedQuery;
          console.log(chalk.green(` â”œâ”€âœ“ AI optimized query: "${optimizedQuery}" (confidence: ${searchStrategy.confidence}%)`));
        }
        
        if (searchStrategy.isAmbiguous && searchStrategy.suggestedAlternatives) {
          console.log(chalk.cyan(` â”œâ”€ğŸ’¡ AI suggests alternatives: ${searchStrategy.suggestedAlternatives.join(", ")}`));
        }
      }
    } catch (err) {
      console.warn(chalk.yellow("âš  AI analysis failed, using original query:"), err.message);
    }

    const youtube = await Innertube.create({
      generate_session_locally: true,
    });

    const search = await youtube.search(optimizedQuery);
    let allVideos = search.results
      .filter((item) => item.type === "Video")
      .slice(0, 20);

    // AI-POWERED VIDEO SCORING
    if (allVideos.length > 0) {
      console.log(chalk.magenta(` â”œâ”€ğŸ§  AI scoring ${allVideos.length} video results..."`));
      
      try {
        const videoTitles = allVideos.slice(0, 10).map((v, i) => 
          `${i + 1}. "${v.title.text}" by ${v.author?.name || 'Unknown'} (${v.duration?.text || 'N/A'})`
        ).join('\n');
        
        const scoringPrompt = `You are an expert video curator. Score these video search results for the query "${optimizedQuery}":

${videoTitles}

Return JSON array with scores 0-100 for each result based on:
- Title relevance to query
- Official vs unofficial (official = higher for music videos)
- Video quality indicators ("HD", "4K", "official", etc.)
- Channel credibility
- Content type matching user intent

Format: [{"index": 1, "score": 95, "reason": "Official HD video from verified channel"}, ...]
Return ONLY valid JSON array, no markdown.`;
        
        const scoringResult = await model.generateContent(scoringPrompt);
        const scoringText = scoringResult?.response && typeof scoringResult.response.text === "function"
          ? await scoringResult.response.text()
          : null;
        
        if (scoringText) {
          const cleanJson = scoringText.replace(/```json\n?|```\n?/g, '').trim();
          const scores = JSON.parse(cleanJson);
          
          scores.sort((a, b) => b.score - a.score);
          const reordered = scores.map(s => allVideos[s.index - 1]).filter(v => v);
          allVideos = reordered.concat(allVideos.filter(v => !reordered.includes(v)));
          
          console.log(chalk.green(` â”œâ”€âœ“ AI ranked videos: #1 scored ${scores[0].score}% - ${scores[0].reason}`));
        }
      } catch (err) {
        console.warn(chalk.yellow("âš  AI video scoring failed, using default order:"), err.message);
      }
    }

    if (allVideos.length === 0) {
      api.setMessageReaction("âŒ", messageID, () => {}, true);
      
      let notFoundText = "âŒ No videos found for your search query.";
      try {
        const notFoundPrompt = `No videos found for search query "${query}". Generate a short message (1 sentence) saying you couldn't find it. Be apologetic and friendly. Use emojis.`;
        const notFoundResult = await model.generateContent(notFoundPrompt);
        notFoundText = notFoundResult?.response && typeof notFoundResult.response.text === "function"
          ? await notFoundResult.response.text()
          : notFoundText;
      } catch {
        console.warn(chalk.yellow("âš  Failed to generate not found message"));
      }
      
      return api.sendMessage(notFoundText.trim(), threadID, messageID);
    }

    // Try to find a video within duration limit
    let selectedVideo = null;
    let videoTitle = "";
    let channelName = "";
    let duration = "";
    let foundWithinLimit = false;

    // First, check if any of the first results are within limit
    for (const video of allVideos) {
      try {
        const info = await youtube.getInfo(video.id);
        if (info.basic_info.duration <= 600 && info.basic_info.duration > 30) {
          selectedVideo = video;
          videoTitle = selectedVideo.title.text;
          channelName = selectedVideo.author?.name || "Unknown";
          duration = selectedVideo.duration?.text || "N/A";
          foundWithinLimit = true;
          console.log(chalk.green(` â”œâ”€âœ“ Found suitable video: ${videoTitle} (${Math.floor(info.basic_info.duration / 60)}:${String(Math.floor(info.basic_info.duration % 60)).padStart(2, '0')})`));
          break;
        }
      } catch {
        continue;
      }
    }

    // If no suitable video found in initial results, try alternative searches
    if (!foundWithinLimit) {
      console.log(chalk.yellow(` â”œâ”€âš  No suitable video in first results, trying alternative searches...`));
      
      const alternativeQueries = [
        `${query} short`,
        `${query} clip`,
        `${query} highlights`,
        `${query} best moments`,
        `${query} compilation`,
        `${query} official video`,
        `${query} short version`
      ];
      
      for (const altQuery of alternativeQueries) {
        try {
          const altSearch = await youtube.search(altQuery);
          const altVideos = altSearch.results
            .filter((item) => item.type === "Video")
            .slice(0, 10);
          
          for (const video of altVideos) {
            const info = await youtube.getInfo(video.id);
            if (info.basic_info.duration <= 600 && info.basic_info.duration > 30) {
              selectedVideo = video;
              videoTitle = selectedVideo.title.text;
              channelName = selectedVideo.author?.name || "Unknown";
              duration = selectedVideo.duration?.text || "N/A";
              foundWithinLimit = true;
              console.log(chalk.green(` â”œâ”€âœ“ Found alternative: ${videoTitle} (${Math.floor(info.basic_info.duration / 60)}:${String(Math.floor(info.basic_info.duration % 60)).padStart(2, '0')})`));
              break;
            }
          }
          
          if (foundWithinLimit) break;
        } catch (err) {
          console.warn(chalk.yellow(`âš  Error in alternative search: ${err.message}`));
          continue;
        }
      }
    }

    // If still no suitable video, use the first result anyway but with a note
    if (!selectedVideo) {
      selectedVideo = allVideos[0];
      videoTitle = selectedVideo.title.text;
      channelName = selectedVideo.author?.name || "Unknown";
      duration = selectedVideo.duration?.text || "N/A";
      console.log(chalk.yellow(` â”œâ”€âš  Using first result despite duration`));
    }

    console.log(chalk.cyan(` â”œâ”€ğŸ¬ Found video: ${videoTitle} (${duration})`));
    api.setMessageReaction("â¬‡ï¸", messageID, () => {}, true);

    const info = await youtube.getInfo(selectedVideo.id);

    // Check duration but continue anyway
    if (info.basic_info.duration > 600) {
      console.log(chalk.yellow(` â”œâ”€âš  Selected video is ${Math.floor(info.basic_info.duration / 60)} min, but will attempt download...`));
    }

    const sanitizedTitle = videoTitle
      .replace(/[/\\?%*:|"<>]/g, "-")
      .slice(0, 100);
    videoPath = path.join(downloadDir, `${Date.now()}-${sanitizedTitle}.mp4`);

    let downloadSuccess = false;
    let lastError = null;
    
    const qualityOptions = [
      { type: "video+audio", quality: "best", format: "mp4" },
      { type: "video+audio", quality: "bestefficiency", format: "mp4" },
      { type: "video", quality: "best", format: "mp4" },
    ];

    for (const options of qualityOptions) {
      try {
        const stream = await youtube.download(selectedVideo.id, options);
        const fileStream = fs.createWriteStream(videoPath);

        for await (const chunk of Utils.streamToIterable(stream)) {
          fileStream.write(chunk);
        }

        fileStream.end();

        await new Promise((resolve) => {
          fileStream.on("finish", resolve);
        });

        downloadSuccess = true;
        break;
      } catch (err) {
        lastError = err;
        if (fs.existsSync(videoPath)) {
          try {
            fs.unlinkSync(videoPath);
          } catch {
            // Ignore cleanup errors
          }
        }
        continue;
      }
    }

    if (!downloadSuccess) {
      throw lastError || new Error("Download failed with all quality options");
    }

    const stats = fs.statSync(videoPath);
    const fileSizeMB = stats.size / (1024 * 1024);

    if (fileSizeMB > 100) {
      fs.unlinkSync(videoPath);
      api.setMessageReaction("âŒ", messageID, () => {}, true);
      
      let tooLargeText = `âš ï¸ Video file is too large (${fileSizeMB.toFixed(2)} MB)\n\nğŸ“ Maximum file size: 100 MB`;
      try {
        const tooLargePrompt = `The video file is too large: ${fileSizeMB.toFixed(2)} MB, but maximum is 100 MB. Generate a short message (1-2 sentences) explaining this. Be apologetic but friendly. Use emojis.`;
        const tooLargeResult = await model.generateContent(tooLargePrompt);
        tooLargeText = tooLargeResult?.response && typeof tooLargeResult.response.text === "function"
          ? await tooLargeResult.response.text()
          : tooLargeText;
      } catch {
        console.warn(chalk.yellow("âš  Failed to generate video too large message"));
      }
      
      return api.sendMessage(tooLargeText.trim(), threadID, messageID);
    }

    console.log(chalk.cyan(` â”œâ”€ğŸ”ƒ Uploading video...`));
    api.setMessageReaction("ğŸ”ƒ", messageID, () => {}, true);

    // Send video with simple caption
    await api.sendMessage(
      {
        body: `ğŸ¬ ${videoTitle}\nğŸ‘¤ ${channelName}`,
        attachment: fs.createReadStream(videoPath),
      },
      threadID
    );

    console.log(chalk.green(` â”œâ”€âœ“ Video sent: ${videoTitle.substring(0, 40)}... (${fileSizeMB.toFixed(2)} MB)`));

    api.setMessageReaction("âœ…", messageID, () => {}, true);

    setTimeout(() => {
      try {
        if (fs.existsSync(videoPath)) {
          fs.unlinkSync(videoPath);
        }
      } catch (_err) {
        console.error(chalk.yellow("âš ï¸ Error cleaning up video file:"), _err.message);
      }
    }, 5000);
  } catch (error) {
    console.error(chalk.red(` â”œâ”€âœ— Video download error: ${error.message}`));

    api.setMessageReaction("âŒ", messageID, () => {}, true);

    if (videoPath && fs.existsSync(videoPath)) {
      try {
        fs.unlinkSync(videoPath);
      } catch {
        // Ignore cleanup errors
      }
    }

    // AI-POWERED ERROR DIAGNOSIS & RECOVERY
    let errorMessage = "âŒ Error downloading video. Try a different search query.";
    
    try {
      const errorAnalysisPrompt = `An error occurred while downloading video for query "${query}". Error: ${error.message}

Diagnose the issue and suggest what the user should try:
- Network/connection issues?
- Video unavailable/restricted/age-gated?
- Invalid search query?
- Video too long/large?
- Technical limitation?

Return JSON:
{
  "diagnosis": "brief explanation of what went wrong",
  "suggestion": "friendly suggestion for what to try next",
  "alternativeQuery": "a better search query if the original was problematic"
}

Return ONLY valid JSON, no markdown.`;
      
      const errorResult = await model.generateContent(errorAnalysisPrompt);
      const errorText = errorResult?.response && typeof errorResult.response.text === "function"
        ? await errorResult.response.text()
        : null;
      
      if (errorText) {
        const cleanJson = errorText.replace(/```json\n?|```\n?/g, '').trim();
        const errorAnalysis = JSON.parse(cleanJson);
        
        console.log(chalk.magenta(` â”œâ”€ğŸ§  AI diagnosed error: ${errorAnalysis.diagnosis}`));
        console.log(chalk.cyan(` â”œâ”€ğŸ’¡ AI suggests: ${errorAnalysis.suggestion}`));
        
        errorMessage = `âŒ ${errorAnalysis.diagnosis}\n\nğŸ’¡ ${errorAnalysis.suggestion}`;
        
        if (errorAnalysis.alternativeQuery && errorAnalysis.alternativeQuery !== query) {
          errorMessage += `\n\nğŸ”„ Try: "${errorAnalysis.alternativeQuery}"`;
        }
      }
    } catch {
      console.warn(chalk.yellow("âš  AI error diagnosis failed"));
    }
    
    if (error.message?.includes("413") || error.message?.includes("Payload Too Large")) {
      errorMessage = "âŒ Video file is too large for Messenger. Try searching for shorter videos.";
    } else if (error.message?.includes("403") || error.message?.includes("Forbidden")) {
      errorMessage = "âŒ Video download blocked by YouTube. Try a different video.";
    } else if (error.message?.includes("404") || error.message?.includes("Not Found")) {
      errorMessage = "âŒ Video not found. It may have been deleted.";
    }

    // Generate AI error message
    try {
      const errorPrompt = `Error downloading video. ${errorMessage}. Generate a short, apologetic message (1-2 sentences) about the error. Be friendly and suggest trying again. Use emojis.`;
      const errorResult = await model.generateContent(errorPrompt);
      errorMessage = errorResult?.response && typeof errorResult.response.text === "function"
        ? await errorResult.response.text()
        : errorMessage;
    } catch {
      console.warn(chalk.yellow("âš  Failed to generate error message"));
    }

    return api.sendMessage(errorMessage.trim(), threadID, messageID);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                              EVENT HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Event execution function
 * @param {Object} context - Event context from handler
 * @param {Object} context.api - Nero API object
 * @param {Object} context.event - Event object
 * @param {Object} context.config - Bot configuration
 * @param {Object} context.logger - Logger utility
 */
module.exports.execute = async function({ api, event, config: _botConfig, logger: _logger }) {
    try {
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // VALIDATION
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      if (!event?.body) return;

      const botID = api.getCurrentUserID?.();
      
      // Don't respond to bot's own messages
      if (event.senderID === botID) return;

      const text = String(event.body).trim();
      if (!text) return;

      const threadID = event.threadID;
      const senderID = event.senderID;

      // Resolve sender name
      const senderName = await getUserName(api, senderID, event);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // UPDATE MEMORY
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      updateChatMemory(threadID, senderName, text);

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CHECK ACTIVATION CONDITIONS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Detect mention (@Beta or "beta")
      const mentionRegex = /\b@?beta\b/i;
      const mentioned = mentionRegex.test(text);
      
      // Detect reply to Beta's previous messages
      const isReplyingToBeta = event.messageReply && 
                               betaMessageIDs.has(event.messageReply.messageID);

      // Exit if not mentioned and not replying to Beta
      if (!mentioned && !isReplyingToBeta) return;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SHOW LOADING INDICATOR (IMMEDIATELY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Show loading reaction right away so user knows Beta is processing
      try {
        api.setMessageReaction("â³", event.messageID, () => {}, true);
      } catch {
        console.warn(chalk.yellow("âš  Could not set loading reaction"));
      }

      // Validate API key (now from config.apiKeys.gemini)
      const apiKey = config.apiKeys?.gemini || config.geminiApiKey;
      if (!apiKey) {
        console.error(chalk.red("âŒ Gemini API key not configured"));
        return;
      }

      // Create model proxy that uses generateWithFallback for automatic API key rotation
      const model = {
        generateContent: async (promptOrParts) => {
          if (Array.isArray(promptOrParts)) {
            // Has image parts - extract prompt and images
            const [prompt, ...images] = promptOrParts;
            return generateWithFallback(prompt, images);
          }
          return generateWithFallback(promptOrParts);
        }
      };

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // GET ALL GROUP MEMBERS FOR CONTEXT
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      const allMembers = await getAllGroupMembers(api, threadID);
      const membersList = Array.from(allMembers.entries())
        .map(([id, name]) => `${id}=${name}`)
        .join("\n");
      
      console.log(chalk.cyan(` â”œâ”€ğŸ‘¥ Group has ${allMembers.size} members`));
      
      // Debug: Log the actual members list being sent to AI
      if (text.toLowerCase().includes('change all') || text.toLowerCase().includes('everyone')) {
        console.log(chalk.magenta(` â”œâ”€ğŸ“‹ Members list for AI:\n${membersList}`));
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // PROCESS IMAGES (IF ANY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      const hasImages = event.type === "message_reply" && 
                        event.messageReply?.attachments?.length > 0;
      
      const imageParts = [];
      
      if (hasImages) {
        const attachments = event.messageReply.attachments;
        const imageCount = Math.min(attachments.length, MAX_IMAGES_PER_REPLY);
        
        for (let i = 0; i < imageCount; i++) {
          const attachment = attachments[i];
          
          if (attachment.type === "photo" || attachment.type === "animated_image") {
            const imageUrl = attachment.url || 
                            attachment.previewUrl || 
                            attachment.largePreviewUrl;
            
            if (imageUrl) {
              const imageData = await downloadImageAsBase64(imageUrl, attachment.type);
              if (imageData) {
                imageParts.push(imageData);
              }
            }
          }
        }
        
        if (imageParts.length > 0) {
          console.log(chalk.cyan(` â”œâ”€ğŸ–¼ï¸ Analyzing ${imageParts.length} image(s)`));
        }
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // GENERATE AI RESPONSE (with automatic API key rotation)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      // Build context from chat history
      const history = chatMemory.get(threadID) || [];
      const contextText = history
        .slice(-MAX_HISTORY)
        .map((h) => `${h.name}: ${h.message}`)
        .join("\n");

      // Build AI prompt
      const imageInstruction = imageParts.length > 0
        ? ` - IMPORTANT: ${imageParts.length} image(s) sent. Analyze ${imageParts.length === 1 ? 'it' : 'them all'} immediately and provide a direct, helpful response. If it's a test paper, homework, quiz, or any questions - answer them directly with explanations. If it's a math problem - solve it step by step. If it's text in an image - read and respond to it. ${imageParts.length > 1 ? 'Compare or relate the images if relevant.' : ''} Don't ask if they want help, just help them directly.`
        : "";

      const membersInstruction = allMembers.size > 0
        ? `\n\n**GROUP MEMBERS LIST**:\n${membersList}\n(Format: UserID=Name, each line shows a 15-digit UserID followed by = and the name)`
        : "";

      const nicknameInstruction = allMembers.size > 0 
        ? `\n\n**NICKNAME COMMANDS**:
For nickname changes, you MUST use REAL Facebook user IDs from the GROUP MEMBERS LIST.

EXTRACTION RULE: Each line format is "<15-digit-number>=<name>"
To get UserID: Take everything BEFORE the = sign (this is always a long number like 100091687191806)

For bulk changes ("change all members" / "everyone"):
1. Split the GROUP MEMBERS LIST by newlines
2. For each line, extract the number before = (use regex: /^(\\d+)=/)
3. Generate a creative name
4. Format as: NICKNAME_BULK: <extracted-id-1>|<name1>||<extracted-id-2>|<name2>||...

For clearing nicknames (remove/reset to default):
- "clear my name/nickname": NICKNAME_CLEAR: ${senderID}
- "clear @mention's name": Extract mentioned user's ID and use NICKNAME_CLEAR: <userID>
- "clear all names/everyone": NICKNAME_CLEAR_ALL (clears all group members' nicknames)

CRITICAL ERROR TO AVOID:
âŒ NEVER use 0, 1, 2, 3... (these are NOT user IDs)
âœ… ALWAYS copy the actual 15-digit numbers from before each = sign

Example:
If GROUP MEMBERS LIST is:
100091687191806=Jay
100012345678901=Alice
100023456789012=Bob

Correct bulk response:
NICKNAME_BULK: 100091687191806|Naruto||100012345678901|Sakura||100023456789012|Sasuke

Single change: NICKNAME_CHANGE: <userID>|<newNickname>
Clear single: NICKNAME_CLEAR: <userID>
Clear all: NICKNAME_CLEAR_ALL
For sender: Use ${senderID}

Clear all: NICKNAME_CLEAR_ALL
For sender: Use ${senderID}

Do NOT add any other text. Just the command.`
        : "";

      const pairingInstruction = allMembers.size > 0
        ? `\n\n**RANDOM PAIRING COMMANDS**:
Users may ask to be paired with someone or ask for random pairings in the group.

PAIRING TYPES:
1. "Pair me with someone" / "kinsa bagay sa akoa" / "who suits me" â†’ Pair sender with random member
2. "Random pairs" / "pair everyone" / "pair random people" â†’ Create random pairs from all members

RESPONSE FORMATS:
- Pair sender only: PAIR_ME
- Pair all members randomly: PAIR_RANDOM

Examples:
User: "kinsa bagay sa akoa?" â†’ PAIR_ME
User: "pair me with someone" â†’ PAIR_ME  
User: "who's my match?" â†’ PAIR_ME
User: "pair random people in gc" â†’ PAIR_RANDOM
User: "random pairs" â†’ PAIR_RANDOM
User: "pair everyone" â†’ PAIR_RANDOM

Do NOT add any other text. Just the command.`
        : "";

      const mediaInstruction = `\n\n**MUSIC & VIDEO DOWNLOADS**:

âš ï¸ MAXIMUM DURATION: 10 MINUTES - Never search for content longer than 10 minutes!

CRITICAL: Distinguish between MUSIC and VIDEO requests carefully!

**MUSIC Downloads (Audio only)**:
When users ask for: music, song, audio, play, listen, soundtrack, track, album
- Response format: MUSIC_DOWNLOAD: <search query>
- âš ï¸ IMPORTANT: If user gives a vague/generic request (like "send music", "play something", "chill music"), you MUST pick an ACTUAL SPECIFIC SONG with real artist name!
- Do NOT search generic terms like "chill relaxing music" or "sad songs" - pick a REAL song title!

Examples:
  * "play ben and ben" â†’ MUSIC_DOWNLOAD: ben and ben pagtingin
  * "send me music" â†’ MUSIC_DOWNLOAD: Ed Sheeran Shape of You (pick a real popular song!)
  * "play something chill" â†’ MUSIC_DOWNLOAD: Cigarettes After Sex Apocalypse (pick an actual chill song!)
  * "sad music please" â†’ MUSIC_DOWNLOAD: Lewis Capaldi Someone You Loved (real sad song!)
  * "music imagine dragons" â†’ MUSIC_DOWNLOAD: imagine dragons believer
  * "send me a song" â†’ MUSIC_DOWNLOAD: The Weeknd Blinding Lights (pick a real hit!)
  * "play relaxing music" â†’ MUSIC_DOWNLOAD: Ludovico Einaudi Nuvole Bianche (real relaxing piano!)

**VIDEO Downloads (Visual content)**:
When users ask for: video, watch, clip, movie, film, vlog, youtube, mv, music video
- Response format: VIDEO_DOWNLOAD: <search query>
- âš ï¸ Add "short" or "under 10 min" to searches to get shorter videos
- Examples:
  * "send video of cats" â†’ VIDEO_DOWNLOAD: funny cats short compilation
  * "video never gonna give you up" â†’ VIDEO_DOWNLOAD: never gonna give you up rick astley official
  * "youtube funny moments" â†’ VIDEO_DOWNLOAD: funny moments compilation short
  * "send me a video" â†’ VIDEO_DOWNLOAD: viral funny videos 2024 short (pick something specific!)

**PROACTIVE MUSIC SUGGESTIONS**:
You can suggest and automatically play music when:
1. Users express emotions (sad, happy, stressed, excited, angry, lonely, etc.)
2. Users mention activities (studying, working out, relaxing, party, sleep, etc.)
3. Users ask for suggestions ("suggest music", "what should I listen to", "recommend a song")
4. Context suggests they might enjoy music

When suggesting music, use this EXACT format:
MUSIC_SUGGESTION: <ACTUAL SONG TITLE by ARTIST> | <1-2 sentence explanation>

âš ï¸ CRITICAL RULES FOR SUGGESTIONS:
- You MUST generate your OWN creative suggestions - NEVER copy the format examples below!
- Use your vast knowledge of music to suggest songs YOU think are good
- Consider different genres: pop, rock, hip-hop, R&B, indie, classical, electronic, K-pop, OPM, etc.
- Suggest lesser-known gems too, not just the same popular songs every time
- Be CREATIVE and VARIED - if asked multiple times, give DIFFERENT songs each time
- Match the song to the user's mood, context, or request
- If they ask for "music with lyrics", suggest lyrical songs with meaningful words

FORMAT EXAMPLES (DO NOT COPY THESE SONGS - generate your own!):
- User asks for sad music â†’ MUSIC_SUGGESTION: [YOUR OWN CHOICE] | [your explanation]
- User asks for study music â†’ MUSIC_SUGGESTION: [YOUR OWN CHOICE] | [your explanation]
- User asks for suggestions â†’ MUSIC_SUGGESTION: [YOUR OWN CHOICE] | [your explanation]

The examples above show the FORMAT only. You must pick your OWN songs based on your music knowledge!

CRITICAL RULES for all media:
- âš ï¸ MAX 10 MINUTES - Never suggest/search for content over 10 minutes
- ALWAYS use REAL song titles with artist names when possible
- NEVER use generic searches like "relaxing music" or "sad songs playlist"
- If user is vague, YOU choose a specific popular song that fits the mood
- Match music genre to the emotion/context
- Only suggest when contextually appropriate

When users ask for weather:
- Response format: WEATHER_CHECK: <location>
- Examples:
  * "weather in manila" â†’ WEATHER_CHECK: manila
  * "how's the weather in tokyo" â†’ WEATHER_CHECK: tokyo
  * "what's the temperature in new york" â†’ WEATHER_CHECK: new york
  * "weather" â†’ WEATHER_CHECK: maasin (default)
  * "what's the weather" â†’ WEATHER_CHECK: maasin (default)

When users ask for date/time:
- Response format: DATETIME_CHECK
- Examples:
  * "what's the date" â†’ DATETIME_CHECK
  * "what time is it" â†’ DATETIME_CHECK
  * "current date and time" â†’ DATETIME_CHECK
  * "what's today's date" â†’ DATETIME_CHECK

Keywords to detect:
- Music: play, song, music, mp3, audio, send me <song name>
- Video: video, youtube, yt, send video
- Weather: weather, temperature, forecast, climate, how's the weather
- Date/Time: date, time, what time, what's the date, current time, today's date

Do NOT add any other text. Just the command with the search query/location.`;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CLASS SCHEDULE CONTEXT (For Jay's classes)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const currentDate = new Date();
      const manilaTime = new Date(currentDate.toLocaleString('en-US', { timeZone: 'Asia/Manila' }));
      const currentDay = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][manilaTime.getDay()];
      const currentHour = manilaTime.getHours();
      const currentMinute = manilaTime.getMinutes();
      const currentTimeFormatted = manilaTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      const currentDateFormatted = manilaTime.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

      // Calculate current time in minutes for comparison
      const currentTotalMinutes = currentHour * 60 + currentMinute;

      // Determine if it's a school day and which type
      const isMWF = ['Monday', 'Wednesday', 'Friday'].includes(currentDay);
      const isTTH = ['Tuesday', 'Thursday'].includes(currentDay);
      const isWeekend = ['Saturday', 'Sunday'].includes(currentDay);

      const scheduleInstruction = `\n\n**ğŸ“ INTELLIGENT ACADEMIC ASSISTANT - JAY'S SCHEDULE**:

You are an intelligent AI assistant with FULL KNOWLEDGE of our academic life. You don't just know the schedule - you UNDERSTAND it and can provide smart, contextual, helpful responses.

â° CURRENT CONTEXT:
- Date: ${currentDateFormatted}
- Time: ${currentTimeFormatted}
- Day Type: ${isWeekend ? 'ğŸ‰ WEEKEND (No Classes)' : isMWF ? 'ğŸ“š MWF Schedule Day' : isTTH ? 'ğŸ“š TTH Schedule Day' : 'ğŸ“š School Day'}
- Current Minutes: ${currentTotalMinutes} (for time calculations)

ğŸ“… SCHEDULE DATABASE (SEPARATED BY PROGRAM):

â•â•â• IT SUBJECTS ONLY â•â•â•
MWF (Monday/Wednesday/Friday):
- 10:30 AM | Theo 3b (The Commandments) | Room 411 | Shared IT/CS
- 11:30 AM | IT EL 1 (IT Elective 1) | Room 422
- 4:00 PM | IT 312 (Analytics Modeling) | Room 409

TTH (Tuesday/Thursday):
- 8:30 AM | IT 314 (Systems Admin and Maintenance) | ILLC
- 2:00 PM | IT 311 (Analytic Tools and Techniques) | ILLC
- 4:00 PM | IT 315 (Integrative Programming and Tech 1) | ILLC
- 5:30 PM | IT EL 2 (IT Elective 2) | Room 407
- 6:30 PM | IT 313 (Social Issues) | Room 409 | Tuesday only

â•â•â• CS SUBJECTS ONLY â•â•â•
MWF (Monday/Wednesday/Friday):
- 10:30 AM | Theo 3b (The Commandments) | Room 411 | Shared IT/CS
- 6:30 PM | CS 312 (Analytics Modeling) | TBA
- 7:30 PM | CS 316 (Programming Languages) | TBA

TTH (Tuesday/Thursday):
- 3:00 PM | CS 311 (Analytics Techniques) | Room 407 | Tuesday only
- 3:00 PM | CS 315 (Software Engineering 2) | Room 407 | Thursday only
- 6:30 PM | CS 313 (Social Issues) | Room 409 | Tuesday only
- 6:30 PM | CS 314 (Operating Systems) | Room 109 | Thursday only
- 7:30 PM | CS EL 2 (CS Elective 2) | TBA

ğŸ¯ CRITICAL FILTERING RULES:
- When user asks "IT schedule" or "IT sched" â†’ ONLY show IT subjects, NEVER include CS!
- When user asks "CS schedule" or "CS sched" â†’ ONLY show CS subjects, NEVER include IT!
- When user asks "schedule today" without specifying â†’ Ask which program (IT or CS) OR show both clearly separated
- When user asks "next class" â†’ Need to know if they're IT or CS student first, or ask!
- Be SPECIFIC - don't mix IT and CS subjects together!

ğŸ§  INTELLIGENT RESPONSE CAPABILITIES:

1. NEXT CLASS CALCULATION: 
   - Compare current time (${currentTotalMinutes} minutes) with class times
   - Find the FIRST class where class_minutes > current_minutes
   - If no more classes today, show first class of next school day
   - Calculate "in X minutes" or "in X hours" countdown

2. SMART CONTEXT AWARENESS:
   - If it's morning, mention "good morning" and morning energy
   - If it's late (after 8PM), acknowledge they're working hard
   - If weekend, remind them to rest and mention Monday's first class
   - If between classes, calculate break time

3. SUBJECT INTELLIGENCE - Know what each subject is about:
   IT SUBJECTS:
   - IT 311: Analytic Tools - Tableau, Power BI, data visualization
   - IT 312: Analytics Modeling - Data models, predictive analytics, ML basics
   - IT 313: Social Issues - Tech ethics, privacy, professional practice
   - IT 314: Systems Admin - Linux, servers, network management, security
   - IT 315: Integrative Programming - APIs, system integration, full-stack
   - IT EL 1/2: IT Electives - Specialized IT topics
   
   CS SUBJECTS:
   - CS 311: Analytics Techniques - Statistical analysis, data mining
   - CS 312: Analytics Modeling - Data models, predictive analytics
   - CS 313: Social Issues - Tech ethics, privacy laws
   - CS 314: Operating Systems - Process management, memory, file systems
   - CS 315: Software Engineering 2 - SDLC, Agile, project management
   - CS 316: Programming Languages - Language paradigms, compilers, syntax theory
   - CS EL 2: CS Elective - Specialized CS topics
   
   SHARED:
   - Theo 3b: Religious/Ethics - The Ten Commandments, moral theology

4. HOMEWORK/STUDY HELP: 
   - If asked about a subject, provide relevant study tips
   - Can explain concepts related to any subject
   - Suggest study resources based on subject matter

5. PROACTIVE INTELLIGENCE:
   - If class is in < 30 min: "âš ï¸ Heads up! Class in X minutes!"
   - If asked about schedule during class hours: "You should be in [Subject] right now!"
   - If late night: "It's late! Tomorrow you have [first class] at [time]"

6. NATURAL RESPONSES - Don't just list data, be conversational and SMART:
   âŒ BAD: "10:30 AM - Theo 3b - Room 411" (too robotic)
   âŒ BAD: "Your next class is *Theo 3b*..." (no asterisks/markdown!)
   âœ… GOOD: "Your first class is Theo 3b (The Commandments) at 10:30 AM in Room 411. It's a theology class about moral principles - perfect time to reflect on ethics! âœ¨"
   
   IMPORTANT: NEVER use asterisks (*), bold (**), or any markdown formatting in responses. Use emojis instead for emphasis!

7. BISAYA/TAGALOG INTELLIGENCE:
   - "unsa klase?" = what class
   - "pila ka klase?" = how many classes
   - "asa room?" = what room
   - "kinsa teacher?" = who's the teacher
   - "dugay pa ba?" = is it still far/long
   - Respond naturally in the same language!

EXAMPLE INTELLIGENT RESPONSES:

Q: "IT schedule today" (MWF day)
A: "ğŸ“š Here's your IT schedule for today (MWF):
â†’ 10:30 AM - Theo 3b (The Commandments) in Room 411
â†’ 11:30 AM - IT EL 1 (IT Elective 1) in Room 422
â†’ 4:00 PM - IT 312 (Analytics Modeling) in Room 409
That's 3 classes! Your first one starts at 10:30 AM â˜•"

Q: "IT schedule today" (TTH day)
A: "ğŸ“š Here's your IT schedule for today (TTH):
â†’ 8:30 AM - IT 314 (Systems Admin) in ILLC
â†’ 2:00 PM - IT 311 (Analytic Tools) in ILLC  
â†’ 4:00 PM - IT 315 (Integrative Programming) in ILLC
â†’ 5:30 PM - IT EL 2 (IT Elective 2) in Room 407
â†’ 6:30 PM - IT 313 (Social Issues) in Room 409
Busy day! 5 IT classes, mostly in ILLC ğŸ–¥ï¸"

Q: "CS schedule today" (MWF day)
A: "ğŸ“š Here's your CS schedule for today (MWF):
â†’ 10:30 AM - Theo 3b (The Commandments) in Room 411
â†’ 6:30 PM - CS 312 (Analytics Modeling) - TBA
â†’ 7:30 PM - CS 316 (Programming Languages) - TBA
3 classes! Long break between morning and evening ğŸŒ™"

Q: "next class?"
A: "Hey! ğŸ‘‹ Your next class is IT 312 (Analytics Modeling) at 4:00 PM in Room 409. That's in about 2 hours! It's a data science class where you'll work with predictive models and ML basics. Don't forget your laptop! ğŸ’»"

Q: "what's IT 314 about?"
A: "IT 314 (Systems Admin and Maintenance) is all about managing IT infrastructure! ğŸ–¥ï¸ You'll learn Linux administration, server setup, network configuration, security hardening, and troubleshooting. It's hands-on work in the ILLC lab every Tuesday and Thursday at 8:30 AM. Super practical skills for any IT career!"

Q: "unsa akong IT sched karon?"
A: "Karon? Let me check... ğŸ˜„ IT schedule nimo for today:
â†’ 8:30 AM - IT 314 sa ILLC
â†’ 2:00 PM - IT 311 sa ILLC
â†’ 4:00 PM - IT 315 sa ILLC
â†’ 5:30 PM - IT EL 2 sa Room 407
â†’ 6:30 PM - IT 313 sa Room 409
Lima ka IT classes! Busy day sa ILLC ğŸƒ"

REMEMBER: You're not a schedule robot - you're an intelligent assistant who KNOWS the schedule AND understands academics. Provide context, tips, encouragement, and be helpful! ğŸ“`;

      const prompt = `
You are Beta, a casual, helpful AI created by Jay Patrick Cano for group chats.

**LANGUAGE HANDLING (CRITICAL)**:
1. DETECT the language of the user's message: "${text}"
2. For COMMANDS (nicknames, music, video, weather, datetime):
   - First, understand the command in ANY language (English, Tagalog, Bisaya, Spanish, Japanese, Korean, Chinese, etc.)
   - Translate the intent to English internally
   - Output the command in the EXACT format required (e.g., MUSIC_DOWNLOAD: <query>)
   - Examples:
     * "ãƒ‘ã‚¬ ng music ng beatles" â†’ MUSIC_DOWNLOAD: beatles
     * "ë¹„ë””ì˜¤ funny cats" â†’ VIDEO_DOWNLOAD: funny cats
     * "å¤©æ°” tokyo" â†’ WEATHER_CHECK: tokyo
     * "cambiar nombre everyone" â†’ NICKNAME_BULK: <userIDs with names>
     * "ë‚ ì”¨ ì–´ë•Œ" â†’ WEATHER_CHECK: maasin
     * "æ™‚é–“ã¯ä½•ã§ã™ã‹" â†’ DATETIME_CHECK
3. For RESPONSES (after command execution or general chat):
   - Reply in the SAME language the user used
   - If they mixed languages, use the dominant language
   - Be natural and conversational in that language

**BEHAVIOR**:
 - Keep replies short and natural when the request is simple; expand only when the topic requires explanation.
 - Be casual, friendly, and respectful. Use light humor when appropriate.
 - When it helps, reference names from the recent chat history to be specific.
 - NEVER use markdown formatting (no asterisks, bold, underscores, backticks). Use emojis for emphasis instead.
 - Be SMART and contextual - don't just recite data, provide helpful insights, tips, and encouragement!
${imageInstruction}${membersInstruction}${nicknameInstruction}${pairingInstruction}${mediaInstruction}${scheduleInstruction}

Context (last ${MAX_HISTORY} messages):
${contextText}

Latest message by ${senderName}:
"${text}"

Reply as Beta, detecting language automatically and responding appropriately.
`;

      // Use generateWithFallback for automatic API key rotation
      const result = await generateWithFallback(prompt, imageParts);

      // Extract response text
      const responseText = result?.response && typeof result.response.text === "function"
        ? await result.response.text()
        : result?.outputText || "";

      if (!responseText || !responseText.trim()) {
        console.warn(chalk.yellow("âš  Empty AI response"));
        
        // Show error reaction
        try {
          api.setMessageReaction("âŒ", event.messageID, () => {}, true);
        } catch {
          console.warn(chalk.yellow("âš  Could not set error reaction"));
        }
        
        return;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SEND RESPONSE (FULL MESSAGE AT ONCE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      const reply = responseText.trim();
      
      // Check for music suggestion requests (proactive)
      const musicSuggestionMatch = reply.match(/MUSIC_SUGGESTION:\s*(.+?)\s*\|\s*(.+)/i);
      if (musicSuggestionMatch) {
        const searchQuery = musicSuggestionMatch[1].trim();
        const explanation = musicSuggestionMatch[2].trim();
        console.log(chalk.cyan(` â”œâ”€ğŸµ Music suggestion: "${searchQuery}"`));
        
        // Send the explanation first
        await api.sendMessage(explanation, threadID, event.messageID);
        
        // Check if user wants lyrics (keywords: lyrics, lyric, letra, lirika)
        const wantsLyrics = /\b(lyrics?|letra|lirika)\b/i.test(text);
        
        // Download the music directly (no wait message)
        await downloadMusic(api, threadID, event.messageID, searchQuery, model, wantsLyrics);
        return;
      }
      
      // Check for music download requests (explicit)
      const musicMatch = reply.match(/MUSIC_DOWNLOAD:\s*(.+)/i);
      if (musicMatch) {
        const searchQuery = musicMatch[1].trim();
        console.log(chalk.cyan(` â”œâ”€ğŸµ Music download request: "${searchQuery}"`));
        
        // Check if user wants lyrics (keywords: lyrics, lyric, letra, lirika)
        const wantsLyrics = /\b(lyrics?|letra|lirika)\b/i.test(text);
        
        // Download directly (no wait message)
        await downloadMusic(api, threadID, event.messageID, searchQuery, model, wantsLyrics);
        return;
      }
      
      // Check for video download requests
      const videoMatch = reply.match(/VIDEO_DOWNLOAD:\s*(.+)/i);
      if (videoMatch) {
        const searchQuery = videoMatch[1].trim();
        console.log(chalk.cyan(` â”œâ”€ğŸ¬ Video download request: "${searchQuery}"`));
        
        await downloadVideo(api, threadID, event.messageID, searchQuery, model);
        return;
      }
      
      // Check for weather requests
      const weatherMatch = reply.match(/WEATHER_CHECK:\s*(.+)/i);
      if (weatherMatch) {
        let location = weatherMatch[1].trim();
        // Use Maasin as default if location is empty or just "weather"
        if (!location || location.toLowerCase() === 'weather' || location.length < 2) {
          location = 'Maasin';
        }
        console.log(chalk.cyan(` â”œâ”€ğŸŒ¤ï¸ Weather request for: "${location}"`));
        
        await getWeather(api, threadID, event.messageID, location);
        return;
      }
      
      // Check for date/time requests
      const datetimeMatch = reply.match(/DATETIME_CHECK/i);
      if (datetimeMatch) {
        console.log(chalk.cyan(` â”œâ”€ğŸ• Date/Time request`));
        
        try {
          api.setMessageReaction("ğŸ•", event.messageID, () => {}, true);
          
          const now = new Date();
          
          // Get comprehensive Manila time information
          const fullDate = now.toLocaleDateString('en-US', {
            timeZone: 'Asia/Manila',
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          const time12h = now.toLocaleTimeString('en-US', {
            timeZone: 'Asia/Manila',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: true
          });
          
          const time24h = now.toLocaleTimeString('en-US', {
            timeZone: 'Asia/Manila',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
          });
          
          // Get day of year
          const startOfYear = new Date(now.getFullYear(), 0, 0);
          const diff = now - startOfYear;
          const oneDay = 1000 * 60 * 60 * 24;
          const dayOfYear = Math.floor(diff / oneDay);
          
          // Get week number
          const startOfYearDate = new Date(now.getFullYear(), 0, 1);
          const days = Math.floor((now - startOfYearDate) / oneDay);
          const weekNumber = Math.ceil((days + startOfYearDate.getDay() + 1) / 7);
          
          const dateTimeMessage = `ğŸ• Current Date & Time (Asia/Manila)

ğŸ“… ${fullDate}

ğŸ• 12-Hour Format: ${time12h}
ğŸ• 24-Hour Format: ${time24h}

ğŸ“Š Additional Info:
  â€¢ Day of Year: ${dayOfYear}
  â€¢ Week Number: ${weekNumber}
  â€¢ Timezone: Asia/Manila (GMT+8)`;
          
          await api.sendMessage(dateTimeMessage, threadID, event.messageID);
          
          console.log(chalk.green(` â”œâ”€âœ“ Date/Time sent: ${fullDate} ${time12h}`));
          
          api.setMessageReaction("âœ…", event.messageID, () => {}, true);
        } catch (error) {
          console.error(chalk.red(` â”œâ”€âœ— Date/Time error: ${error.message}`));
          api.setMessageReaction("âŒ", event.messageID, () => {}, true);
          await api.sendMessage("âŒ Error getting date/time information.", threadID, event.messageID);
        }
        
        return;
      }
      
      // Check for random pairing commands
      if (reply.includes('PAIR_ME')) {
        console.log(chalk.cyan(` â”œâ”€ğŸ’‘ Pairing sender with random member...`));
        
        const pairs = generateRandomPairs(allMembers, senderID, false);
        
        if (pairs.length === 0 || !pairs[0].person2) {
          await api.sendMessage(
            "âŒ Not enough members in the group to create a pair!",
            threadID,
            event.messageID
          );
          api.setMessageReaction("âŒ", event.messageID, () => {}, true);
          return;
        }
        
        const pair = pairs[0];
        
        // Generate AI pairing message
        try {
          const pairingPrompt = `You just paired ${pair.person1.name} with ${pair.person2.name} in a group chat! Generate a fun, playful announcement (2-3 sentences) about this pairing. Be creative and add some humor or personality. Use emojis. Keep it in ${text.toLowerCase().includes('bisaya') || text.toLowerCase().includes('kinsa') ? 'Bisaya' : 'English'}.`;
          
          const pairingResult = await model.generateContent(pairingPrompt);
          const pairingMessage = pairingResult?.response && typeof pairingResult.response.text === "function"
            ? await pairingResult.response.text()
            : `ğŸ’‘ ${pair.person1.name} âœ¨ ${pair.person2.name}\n\nLooks like you two are a match! ğŸ’•`;
          
          await api.sendMessage(pairingMessage.trim(), threadID, event.messageID);
          
          console.log(chalk.green(` â”œâ”€âœ“ Paired: ${pair.person1.name} with ${pair.person2.name}`));
        } catch {
          console.warn(chalk.yellow("âš  Failed to generate pairing message"));
          await api.sendMessage(
            `ğŸ’‘ ${pair.person1.name} âœ¨ ${pair.person2.name}\n\nLooks like you two are a match! ğŸ’•`,
            threadID,
            event.messageID
          );
        }
        
        api.setMessageReaction("ğŸ’•", event.messageID, () => {}, true);
        return;
      }
      
      if (reply.includes('PAIR_RANDOM')) {
        console.log(chalk.cyan(` â”œâ”€ğŸ’‘ Creating random pairs for all members...`));
        
        if (allMembers.size < 2) {
          await api.sendMessage(
            "âŒ Not enough members in the group to create pairs!",
            threadID,
            event.messageID
          );
          api.setMessageReaction("âŒ", event.messageID, () => {}, true);
          return;
        }
        
        const pairs = generateRandomPairs(allMembers, senderID, true);
        
        // Generate AI pairing announcement
        try {
          const pairsText = pairs.map((pair, index) => {
            if (pair.person2) {
              return `${index + 1}. ${pair.person1.name} ğŸ’• ${pair.person2.name}`;
            } else {
              return `${index + 1}. ${pair.person1.name} âœ¨ (Solo)`;
            }
          }).join('\n');
          
          const pairingPrompt = `You just created random pairs for a group chat! Here are the pairs:\n${pairsText}\n\nGenerate a fun, playful announcement (2-3 sentences) introducing these pairs. Be creative and add some humor. Use emojis. Keep it in ${text.toLowerCase().includes('bisaya') || text.toLowerCase().includes('random') ? 'Bisaya' : 'English'}.`;
          
          const pairingResult = await model.generateContent(pairingPrompt);
          const pairingMessage = pairingResult?.response && typeof pairingResult.response.text === "function"
            ? await pairingResult.response.text()
            : `ğŸ’• Random Pairs Generated! ğŸ’•\n\n${pairsText}\n\nHave fun! âœ¨`;
          
          await api.sendMessage(
            `${pairingMessage.trim()}\n\n${pairsText}`,
            threadID,
            event.messageID
          );
          
          console.log(chalk.green(` â”œâ”€âœ“ Created ${pairs.length} random pairs`));
        } catch {
          console.warn(chalk.yellow("âš  Failed to generate pairing message"));
          const pairsText = pairs.map((pair, index) => {
            if (pair.person2) {
              return `${index + 1}. ${pair.person1.name} ğŸ’• ${pair.person2.name}`;
            } else {
              return `${index + 1}. ${pair.person1.name} âœ¨ (Solo)`;
            }
          }).join('\n');
          
          await api.sendMessage(
            `ğŸ’• Random Pairs Generated! ğŸ’•\n\n${pairsText}\n\nHave fun! âœ¨`,
            threadID,
            event.messageID
          );
        }
        
        api.setMessageReaction("ğŸ’•", event.messageID, () => {}, true);
        return;
      }
      
      // Check for bulk nickname changes (change all members)
      const bulkMatch = reply.match(/NICKNAME_BULK:\s*(.+)/);
      if (bulkMatch) {
        const bulkData = bulkMatch[1];
        const changes = bulkData.split('||').map(pair => {
          const [id, name] = pair.split('|');
          return { id: id.trim(), name: name.trim() };
        }).filter(change => {
          // Validate that ID is a real user ID (not an array index)
          const isValid = change.id.length > 5 && /^\d+$/.test(change.id);
          if (!isValid) {
            console.log(chalk.red(` â”œâ”€âœ— Invalid ID detected: ${change.id} - Skipping`));
          }
          return isValid;
        });
        
        if (changes.length === 0) {
          console.log(chalk.red(` â”œâ”€âœ— No valid user IDs found in bulk change request`));
          console.log(chalk.yellow(` â”œâ”€ğŸ’¡ AI needs to use REAL user IDs from the members list, not array indexes`));
          
          // Ask AI to try again with a hint
          await api.sendMessage(
            "âš ï¸ Please use the actual user IDs from the group members list, not array indexes. Try again!",
            threadID,
            event.messageID
          );
          
          try {
            api.setMessageReaction("âŒ", event.messageID, () => {}, true);
          } catch {
            console.warn(chalk.yellow("âš  Could not set error reaction"));
          }
          
          return;
        }
        
        console.log(chalk.cyan(` â”œâ”€ğŸ­ Bulk nickname change: ${changes.length} members`));
        
        let successCount = 0;
        let failCount = 0;
        
        for (const change of changes) {
          const memberName = allMembers.get(change.id) || 'Unknown';
          console.log(chalk.yellow(` â”œâ”€  Changing ${memberName} (${change.id}) to "${change.name}"`));
          const success = await changeNickname(api, threadID, change.id, change.name);
          if (success) {
            successCount++;
          } else {
            failCount++;
          }
          // Small delay between changes to avoid rate limiting
          await new Promise(resolve => { setTimeout(resolve, 500); });
        }
        
        console.log(chalk.green(` â”œâ”€âœ“ Bulk complete: ${successCount} success, ${failCount} failed`));
        
        // Ask AI to generate a creative success message
        const successPrompt = `You just successfully changed ${successCount} nicknames in the group chat! Generate a short, fun celebration message (2-3 sentences) and mention that you can also change individual nicknames by saying "beta change my name to [nickname]" or mentioning someone. Keep it casual and friendly in ${text.toLowerCase().includes('bisaya') ? 'Bisaya' : 'English'}.`;
        
        try {
          const successResult = await model.generateContent(successPrompt);
          const successMessage = successResult?.response && typeof successResult.response.text === "function"
            ? await successResult.response.text()
            : `âœ¨ Done! Changed ${successCount} nickname${successCount !== 1 ? 's' : ''} successfully! ğŸ­`;
          
          await api.sendMessage(successMessage.trim(), threadID, event.messageID);
        } catch {
          console.warn(chalk.yellow("âš  Failed to generate success message, using fallback"));
          await api.sendMessage(
            `âœ¨ Done! Changed ${successCount} nickname${successCount !== 1 ? 's' : ''} successfully! ğŸ­\n\nğŸ’¡ Tip: I can also change individual nicknames! Try "beta change my name to [nickname]"`,
            threadID,
            event.messageID
          );
        }
        
        // Success reaction
        try {
          api.setMessageReaction("âœ…", event.messageID, () => {}, true);
        } catch {
          console.warn(chalk.yellow("âš  Could not set success reaction"));
        }
        
        return;
      }
      
      // Check for clearing all nicknames
      const clearAllMatch = reply.match(/NICKNAME_CLEAR_ALL/);
      if (clearAllMatch) {
        console.log(chalk.cyan(` â”œâ”€ğŸ§¹ Clearing all nicknames`));
        
        let successCount = 0;
        let failCount = 0;
        
        for (const [userID, userName] of allMembers.entries()) {
          console.log(chalk.yellow(` â”œâ”€  Clearing nickname for ${userName} (${userID})`));
          const success = await changeNickname(api, threadID, userID, "");
          if (success) {
            successCount++;
          } else {
            failCount++;
          }
          // Small delay between changes to avoid rate limiting
          await new Promise(resolve => { setTimeout(resolve, 500); });
        }
        
        console.log(chalk.green(` â”œâ”€âœ“ Clear all complete: ${successCount} success, ${failCount} failed`));
        
        // Generate AI success message for clearing
        const clearPrompt = `You just cleared ${successCount} nicknames (reset to default names) in the group chat! Generate a short, friendly message (2 sentences) confirming this. Keep it casual in ${text.toLowerCase().includes('bisaya') ? 'Bisaya' : 'English'}.`;
        
        try {
          const clearResult = await model.generateContent(clearPrompt);
          const clearMessage = clearResult?.response && typeof clearResult.response.text === "function"
            ? await clearResult.response.text()
            : `âœ¨ Cleared ${successCount} nickname${successCount !== 1 ? 's' : ''}! Everyone's back to their default names. ğŸ§¹`;
          
          await api.sendMessage(clearMessage.trim(), threadID, event.messageID);
        } catch {
          console.warn(chalk.yellow("âš  Failed to generate clear message, using fallback"));
          await api.sendMessage(
            `âœ¨ Cleared ${successCount} nickname${successCount !== 1 ? 's' : ''}! Everyone's back to their default names. ğŸ§¹`,
            threadID,
            event.messageID
          );
        }
        
        // Success reaction
        try {
          api.setMessageReaction("âœ…", event.messageID, () => {}, true);
        } catch {
          console.warn(chalk.yellow("âš  Could not set success reaction"));
        }
        
        return;
      }
      
      // Check for clearing single nickname
      const clearMatch = reply.match(/NICKNAME_CLEAR:\s*(\d+)/);
      if (clearMatch) {
        let [, targetID] = clearMatch;
        
        console.log(chalk.yellow(` â”œâ”€ğŸ“ Clear nickname request for: ${targetID}`));
        
        // Override with sender's ID if "my name" is mentioned
        const textLower = text.toLowerCase();
        if (textLower.includes('my name') || textLower.includes('my nickname')) {
          targetID = senderID;
          console.log(chalk.yellow(` â”œâ”€ğŸ”„ Override: Using sender's ID: ${targetID}`));
        }
        
        // Extract mentioned user ID if there's a mention
        if (event.mentions && Object.keys(event.mentions).length > 0) {
          const mentionedIDs = Object.keys(event.mentions);
          targetID = mentionedIDs[0];
          console.log(chalk.yellow(` â”œâ”€ğŸ”„ Override: Using mentioned user ID: ${targetID}`));
        }
        
        const targetName = allMembers.get(targetID) || 'User';
        console.log(chalk.cyan(` â”œâ”€ğŸ§¹ Clearing nickname for ${targetName} (${targetID})`));
        
        const success = await changeNickname(api, threadID, targetID, "");
        
        if (success) {
          console.log(chalk.green(` â”œâ”€âœ“ Nickname cleared successfully`));
          
          // Success reaction only - no message
          try {
            api.setMessageReaction("âœ…", event.messageID, () => {}, true);
          } catch {
            console.warn(chalk.yellow("âš  Could not set success reaction"));
          }
        } else {
          console.error(chalk.red(` â”œâ”€âœ— Failed to clear nickname`));
          
          // Show error reaction
          try {
            api.setMessageReaction("âŒ", event.messageID, () => {}, true);
          } catch {
            console.warn(chalk.yellow("âš  Could not set error reaction"));
          }
        }
        
        return;
      }
      
      // Check if AI wants to change a nickname
      const nicknameMatch = reply.match(/NICKNAME_CHANGE:\s*(\d+)\|(.+)/);
      if (nicknameMatch) {
        let [, targetID] = nicknameMatch;
        const newNickname = nicknameMatch[2];
        
        console.log(chalk.yellow(` â”œâ”€ğŸ“ Original AI suggestion: targetID=${targetID}, nickname="${newNickname}"`));
        
        // If the message contains "my name" or "my nickname", override with sender's ID
        const textLower = text.toLowerCase();
        if (textLower.includes('my name') || textLower.includes('my nickname') || textLower.includes('call me')) {
          targetID = senderID;
          console.log(chalk.yellow(` â”œâ”€ğŸ”„ Override: Using sender's ID: ${targetID}`));
        }
        
        // Extract mentioned user ID if there's a mention in the message
        if (event.mentions && Object.keys(event.mentions).length > 0) {
          const mentionedIDs = Object.keys(event.mentions);
          targetID = mentionedIDs[0]; // Use the first mentioned user
          console.log(chalk.yellow(` â”œâ”€ğŸ”„ Override: Using mentioned user ID: ${targetID}`));
        }
        
        console.log(chalk.cyan(` â”œâ”€âœï¸ Final: Changing nickname for ${targetID} to "${newNickname}"`));
        console.log(chalk.cyan(` â”œâ”€ğŸ“ ThreadID: ${threadID}`));
        
        const success = await changeNickname(api, threadID, targetID, newNickname);
        
        if (success) {
          console.log(chalk.green(` â”œâ”€âœ“ Nickname change completed successfully`));
          
          // Success reaction only - no message
          try {
            api.setMessageReaction("âœ…", event.messageID, () => {}, true);
          } catch {
            console.warn(chalk.yellow("âš  Could not set success reaction"));
          }
        } else {
          console.error(chalk.red(` â”œâ”€âœ— Nickname change failed`));
          
          // Show error reaction
          try {
            api.setMessageReaction("âŒ", event.messageID, () => {}, true);
          } catch {
            console.warn(chalk.yellow("âš  Could not set error reaction"));
          }
        }
        
        return;
      }
      
      // Send the response - human behavior (typing indicator, delays) is already
      // built into api.sendMessage() when humanBehavior is enabled in settings
      try {
        // Send typing indicator while "thinking"
        if (api.sendTypingIndicator) {
          await api.sendTypingIndicator(true, threadID);
        }

        // Send the full message at once
        const sentMessage = await api.sendMessage(reply, threadID, event.messageID);
        
        // Success reaction
        try {
          api.setMessageReaction("âœ…", event.messageID, () => {}, true);
        } catch {
          console.warn(chalk.yellow("âš  Could not set success reaction"));
        }

        // Track message for reply detection
        if (sentMessage?.messageID) {
          trackBetaMessage(sentMessage.messageID);
        }
        
        console.log(chalk.cyan(` â”œâ”€ğŸ¤– Beta replied: "${reply.substring(0, 100)}..."`));
      } catch (sendErr) {
        console.error(chalk.red("âŒ Failed to send message:"), sendErr.message);
        try {
          api.setMessageReaction("âŒ", event.messageID, () => {}, true);
        } catch {
          console.warn(chalk.yellow("âš  Could not set error reaction"));
        }
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // UPDATE MEMORY WITH BETA'S REPLY
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      
      updateChatMemory(threadID, "Beta", reply);

    } catch (err) {
      console.error(chalk.red("âŒ neroAI handler error:"), err.message || err);
      
      // Show error reaction
      try {
        api.setMessageReaction("âŒ", event.messageID, () => {}, true);
      } catch {
        // Silent fail for error reactions
      }
    }
};
